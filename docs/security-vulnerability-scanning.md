# Security Vulnerability Scanning for Homeostasis

This document describes the comprehensive security vulnerability scanning infrastructure integrated into the Homeostasis testing framework.

## Overview

The security scanning framework provides automated vulnerability detection across multiple dimensions:

- **Dependency Scanning**: Identifies known vulnerabilities in third-party dependencies
- **Static Code Analysis**: Detects security issues in source code
- **Container Scanning**: Analyzes Docker images and Dockerfiles for security problems
- **Infrastructure as Code (IaC) Scanning**: Finds misconfigurations in Terraform, Kubernetes, and other IaC files
- **Runtime Security Testing**: Identifies vulnerabilities during test execution

## Architecture

### Core Components

1. **SecurityScanner Base Class**: Abstract base for all scanner implementations
2. **DependencyVulnerabilityScanner**: Scans package dependencies across multiple languages
3. **StaticCodeSecurityScanner**: Performs static analysis on source code
4. **ContainerSecurityScanner**: Analyzes container configurations and images
5. **IaCSecurityScanner**: Validates infrastructure configurations
6. **SecurityTestOrchestrator**: Coordinates multiple scanners and generates reports

### Data Models

- **SecurityVulnerability**: Represents a single vulnerability finding
- **SecurityScanResult**: Contains results from a security scan
- **SecurityReport**: Consolidated report from all scanners

## Usage

### Basic Usage in Tests

```python
from modules.testing.security_scanner import SecurityTestOrchestrator

# Create orchestrator
orchestrator = SecurityTestOrchestrator()

# Run security scan on a directory
results = await orchestrator.run_security_scan(Path("/path/to/project"))

# Generate report
report = orchestrator.generate_security_report(results)
```

### Integration with Language Tests

The security scanner is automatically integrated with the language integration test framework:

```python
# Security scanning is enabled by default
runner = LanguageIntegrationTestRunner(language, plugin)

# Disable if needed
runner.enable_security_scanning = False

# Run tests - security scanning happens automatically
result = await runner.run_test(test_case)

# Access security results
if result.security_report:
    print(f"Found {result.security_report['summary']['total_vulnerabilities']} vulnerabilities")
```

### CI/CD Integration

Add to your GitHub Actions workflow:

```yaml
- name: Security Vulnerability Scan
  uses: ./.github/workflows/security-scanning.yml
  with:
    scan_type: all  # Options: all, dependency, static_code, container, iac
```

## Supported Languages and Tools

### Dependency Scanning

| Language | Tools Used | File Patterns |
|----------|-----------|---------------|
| Python | Safety, pip-audit | requirements.txt, Pipfile, poetry.lock |
| JavaScript/Node | npm audit, yarn audit | package.json, yarn.lock |
| Go | govulncheck | go.mod |
| Java | OWASP Dependency Check | pom.xml, build.gradle |
| Ruby | bundle-audit | Gemfile |
| PHP | Local PHP Security Checker | composer.json |
| Rust | cargo-audit | Cargo.toml |
| .NET | dotnet list vulnerable | *.csproj |

### Static Code Analysis

| Language | Tools Used | Security Checks |
|----------|-----------|-----------------|
| Python | Bandit | Injection, insecure deserialization, hardcoded secrets |
| JavaScript | ESLint Security | XSS, injection, insecure randomness |
| TypeScript | ESLint Security | Same as JavaScript |
| Go | gosec | SQL injection, hardcoded credentials, insecure crypto |
| Java | SpotBugs + FindSecBugs | OWASP Top 10 vulnerabilities |
| C/C++ | cppcheck, flawfinder | Buffer overflows, format strings |
| Ruby | Brakeman | Rails-specific vulnerabilities |
| PHP | Psalm, PHPStan | SQL injection, XSS, insecure file operations |

### Container Scanning

- **Dockerfile Analysis**: hadolint
- **Image Scanning**: Trivy, Grype
- **Checks**: Base image vulnerabilities, misconfigurations, exposed secrets

### IaC Scanning

- **Terraform**: Checkov, tfsec
- **Kubernetes**: kubesec, Polaris
- **CloudFormation**: cfn-lint with security rules
- **Ansible**: ansible-lint with security policies

## Security Checks Performed

### 1. Dependency Vulnerabilities
- Known CVEs in dependencies
- Outdated packages with security fixes
- License compliance issues
- Supply chain attacks

### 2. Code Security Issues
- **Injection Flaws**: SQL, NoSQL, OS command, LDAP
- **Authentication Issues**: Hardcoded passwords, weak crypto
- **Data Exposure**: Sensitive data in logs, improper error handling
- **Security Misconfigurations**: Debug mode, default passwords
- **XSS**: Reflected, stored, DOM-based
- **Insecure Deserialization**: Pickle, YAML, JSON
- **Using Components with Known Vulnerabilities**
- **Insufficient Logging & Monitoring**

### 3. Container Security
- **Base Image Vulnerabilities**: OS and package vulnerabilities
- **Dockerfile Issues**: Running as root, exposed ports, missing health checks
- **Secret Management**: Embedded secrets, API keys
- **Resource Limits**: Missing CPU/memory limits

### 4. Infrastructure Security
- **Network Security**: Open security groups, missing encryption
- **Access Control**: Overly permissive IAM policies
- **Data Security**: Unencrypted storage, missing backups
- **Compliance**: HIPAA, PCI-DSS, SOC2 violations

## Configuration

### Scanner Configuration

Create a `.security-scan.yml` file in your project:

```yaml
security_scan:
  enabled: true
  
  severity_threshold: medium  # Minimum severity to report
  
  scanners:
    dependency:
      enabled: true
      exclude_paths:
        - vendor/
        - node_modules/
    
    static_code:
      enabled: true
      languages:
        - python
        - javascript
        - go
      custom_rules:
        - rule: no-eval
          pattern: "eval\\("
          severity: high
          message: "Use of eval() is dangerous"
    
    container:
      enabled: true
      scan_images: true
      registries:
        - docker.io
    
    iac:
      enabled: true
      frameworks:
        - terraform
        - kubernetes
  
  reporting:
    format: json  # json, html, sarif
    output_path: security-report.json
    
  integrations:
    github:
      create_issues: true
      pr_comments: true
    
    slack:
      webhook_url: ${SLACK_WEBHOOK_URL}
      notify_on: [critical, high]
```

### Environment Variables

- `SECURITY_SCAN_ENABLED`: Enable/disable scanning (default: true)
- `SECURITY_SCAN_TYPES`: Comma-separated list of scan types
- `SECURITY_SEVERITY_THRESHOLD`: Minimum severity to report
- `SECURITY_SCAN_TIMEOUT`: Timeout for each scanner in seconds

## Output Formats

### JSON Report

```json
{
  "timestamp": "2024-01-20T10:30:00Z",
  "summary": {
    "total_vulnerabilities": 15,
    "by_severity": {
      "critical": 2,
      "high": 5,
      "medium": 6,
      "low": 2,
      "info": 0
    },
    "by_category": {
      "dependency": 8,
      "code": 4,
      "container": 2,
      "iac": 1
    }
  },
  "vulnerabilities": [
    {
      "id": "npm-1523",
      "severity": "high",
      "category": "dependency",
      "title": "Prototype Pollution in lodash",
      "affected_component": "lodash@4.17.11",
      "cve_ids": ["CVE-2019-10744"],
      "remediation": "Update to lodash@4.17.19 or later"
    }
  ]
}
```

### HTML Report

A comprehensive HTML report is generated with:
- Executive summary with charts
- Detailed vulnerability listings
- Remediation recommendations
- Trend analysis over time

### SARIF Format

For integration with GitHub Advanced Security and other tools.

## Best Practices

### 1. Regular Scanning
- Run scans on every pull request
- Schedule daily scans on main branch
- Scan before deployments

### 2. Baseline Management
- Establish security baselines for your project
- Track vulnerability trends over time
- Set quality gates for releases

### 3. False Positive Management
- Use `.security-ignore` file for false positives
- Document reasons for ignoring vulnerabilities
- Review ignored items regularly

### 4. Remediation Workflow
1. **Triage**: Assess severity and exploitability
2. **Prioritize**: Focus on critical and high severity first
3. **Fix**: Apply patches or implement workarounds
4. **Verify**: Re-scan to confirm resolution
5. **Document**: Update security documentation

### 5. Integration with Development

```python
# Pre-commit hook example
@security_scan(fail_on_severity="high")
def pre_commit_security_check():
    """Run security scan before commit."""
    pass

# Decorator for security-sensitive functions
@requires_security_review
def handle_user_input(data):
    """Process user data securely."""
    pass
```

## Performance Considerations

- **Caching**: Vulnerability databases are cached for 24 hours
- **Parallel Scanning**: Multiple scanners run concurrently
- **Incremental Scans**: Only scan changed files when possible
- **Resource Limits**: Configurable CPU and memory limits

## Troubleshooting

### Common Issues

1. **Scanner Tool Not Found**
   ```bash
   # Install all security tools
   make install-security-tools
   ```

2. **Scan Timeout**
   ```bash
   # Increase timeout
   export SECURITY_SCAN_TIMEOUT=600
   ```

3. **High Memory Usage**
   ```yaml
   # Limit parallel scanners
   security_scan:
     max_parallel_scanners: 2
   ```

### Debug Mode

Enable detailed logging:

```bash
export SECURITY_SCAN_DEBUG=true
export SECURITY_SCAN_LOG_LEVEL=DEBUG
```

## Extending the Framework

### Adding a New Scanner

```python
from modules.testing.security_scanner import SecurityScanner

class MyCustomScanner(SecurityScanner):
    def __init__(self):
        super().__init__()
        self.name = "MyCustomScanner"
        
    async def scan(self, target_path: Path, options: Dict[str, Any] = None) -> SecurityScanResult:
        vulnerabilities = []
        
        # Implement scanning logic
        # ...
        
        return SecurityScanResult(
            scan_id=self._generate_scan_id(),
            scan_type="custom",
            target_path=str(target_path),
            vulnerabilities=vulnerabilities,
            # ...
        )
```

### Custom Security Rules

```python
# Add custom rule to static analyzer
scanner.add_rule({
    "id": "CUSTOM-001",
    "pattern": r"unsafe_function\(",
    "severity": "high",
    "message": "Use of unsafe_function detected",
    "cwe": "CWE-242"
})
```

## Compliance and Standards

The security scanner helps meet compliance requirements for:

- **OWASP Top 10**: Automated detection of common vulnerabilities
- **CWE/SANS Top 25**: Coverage of dangerous software errors
- **PCI DSS**: Security testing requirements
- **HIPAA**: Security rule compliance
- **SOC 2**: Vulnerability management controls

## Future Enhancements

1. **Machine Learning**: Anomaly detection for zero-day vulnerabilities
2. **Dynamic Analysis**: Runtime security testing during execution
3. **Threat Modeling**: Automated threat model generation
4. **Security Metrics**: Risk scoring and trending
5. **Auto-Remediation**: Automated fix generation for common issues

## Contributing

To contribute to the security scanning framework:

1. Add new scanner implementations
2. Improve detection rules
3. Add support for new languages/frameworks
4. Enhance reporting capabilities
5. Optimize performance

See [CONTRIBUTING.md](../CONTRIBUTING.md) for guidelines.

## References

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [CWE/SANS Top 25](https://cwe.mitre.org/top25/)
- [NIST Vulnerability Database](https://nvd.nist.gov/)
- [GitHub Advisory Database](https://github.com/advisories)