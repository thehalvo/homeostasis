{
  "name": "TypeScript Performance Error Patterns",
  "description": "Performance optimization patterns for TypeScript applications",
  "version": "1.0.0",
  "rules": [
    {
      "id": "typescript_performance_excessive_type_checking",
      "pattern": "Type instantiation is excessively deep|Type.*too complex|Maximum call stack.*type checking",
      "type": "PerformanceError",
      "description": "Excessive type checking complexity causing compilation slowdown",
      "root_cause": "type_complexity",
      "suggestion": "Simplify complex type definitions, use type aliases, break down deeply nested types, consider using 'any' for problematic cases",
      "category": "typescript",
      "subcategory": "compilation",
      "severity": "high",
      "confidence": "high",
      "tags": ["performance", "types", "compilation"]
    },
    {
      "id": "typescript_performance_large_union_types",
      "pattern": "union type.*too large|excessive union members|union type.*performance",
      "type": "PerformanceError",
      "description": "Large union types causing type checking performance issues",
      "root_cause": "union_complexity",
      "suggestion": "Reduce union type members, use discriminated unions, consider using type predicates or narrowing",
      "category": "typescript",
      "subcategory": "types",
      "severity": "medium",
      "confidence": "high",
      "tags": ["performance", "union", "types"]
    },
    {
      "id": "typescript_performance_recursive_types",
      "pattern": "recursive type|circular type reference|infinite type recursion",
      "type": "PerformanceError",
      "description": "Recursive type definitions causing performance issues",
      "root_cause": "recursive_types",
      "suggestion": "Limit recursion depth, use conditional types with proper termination, consider using interface inheritance",
      "category": "typescript",
      "subcategory": "types",
      "severity": "high",
      "confidence": "medium",
      "tags": ["performance", "recursion", "types"]
    },
    {
      "id": "typescript_performance_spread_in_loop",
      "pattern": "spread operator in loop|\\.\\.\\. inside (for|while)|array spread performance",
      "type": "PerformanceError",
      "description": "Using spread operator in loops causing O(nÂ²) complexity",
      "root_cause": "inefficient_spread",
      "suggestion": "Use array.push() or array.concat() instead of spread in loops, or collect items and spread once",
      "category": "typescript",
      "subcategory": "algorithm",
      "severity": "high",
      "confidence": "high",
      "tags": ["performance", "spread", "loop"]
    },
    {
      "id": "typescript_performance_unnecessary_type_assertions",
      "pattern": "excessive type assertions|as any.*everywhere|unnecessary cast",
      "type": "PerformanceError",
      "description": "Excessive type assertions bypassing type checking benefits",
      "root_cause": "type_assertion_overuse",
      "suggestion": "Fix underlying type issues instead of using assertions, use proper type guards and narrowing",
      "category": "typescript",
      "subcategory": "types",
      "severity": "medium",
      "confidence": "medium",
      "tags": ["performance", "assertions", "types"]
    },
    {
      "id": "typescript_performance_enum_overhead",
      "pattern": "large enum|enum with.*computed values|enum reverse mapping overhead",
      "type": "PerformanceError",
      "description": "Enum usage creating runtime overhead",
      "root_cause": "enum_overhead",
      "suggestion": "Use const enums for compile-time optimization, or use union types of string literals",
      "category": "typescript",
      "subcategory": "enum",
      "severity": "low",
      "confidence": "high",
      "tags": ["performance", "enum", "runtime"]
    },
    {
      "id": "typescript_performance_barrel_exports",
      "pattern": "barrel export|index\\.ts.*export \\*|circular dependency.*barrel",
      "type": "PerformanceError",
      "description": "Barrel exports causing slow compilation and circular dependencies",
      "root_cause": "barrel_exports",
      "suggestion": "Use direct imports instead of barrel exports, or use explicit named exports",
      "category": "typescript",
      "subcategory": "modules",
      "severity": "medium",
      "confidence": "medium",
      "tags": ["performance", "imports", "compilation"]
    },
    {
      "id": "typescript_performance_mapped_type_complexity",
      "pattern": "mapped type.*too complex|keyof.*performance|complex conditional type",
      "type": "PerformanceError",
      "description": "Complex mapped types slowing down type checking",
      "root_cause": "mapped_type_complexity",
      "suggestion": "Simplify mapped types, cache intermediate type results, use type aliases for complex mappings",
      "category": "typescript",
      "subcategory": "types",
      "severity": "medium",
      "confidence": "medium",
      "tags": ["performance", "mapped", "types"]
    },
    {
      "id": "typescript_performance_import_star",
      "pattern": "import \\*.*from|namespace import performance|importing entire module",
      "type": "PerformanceError",
      "description": "Importing entire modules affecting bundle size and tree shaking",
      "root_cause": "import_overhead",
      "suggestion": "Use named imports for better tree shaking, avoid namespace imports",
      "category": "typescript",
      "subcategory": "modules",
      "severity": "medium",
      "confidence": "high",
      "tags": ["performance", "imports", "bundling"]
    },
    {
      "id": "typescript_performance_any_proliferation",
      "pattern": "implicit any|noImplicitAny.*disabled|any type proliferation",
      "type": "PerformanceError",
      "description": "Excessive use of 'any' type defeating TypeScript benefits",
      "root_cause": "any_overuse",
      "suggestion": "Enable noImplicitAny, use unknown instead of any, add proper type annotations",
      "category": "typescript",
      "subcategory": "types",
      "severity": "medium",
      "confidence": "high",
      "tags": ["performance", "any", "types"]
    },
    {
      "id": "typescript_performance_compilation_memory",
      "pattern": "out of memory.*tsc|TypeScript heap|compilation memory limit",
      "type": "MemoryError",
      "description": "TypeScript compilation running out of memory",
      "root_cause": "compilation_memory",
      "suggestion": "Increase Node memory limit, use project references, enable incremental compilation",
      "category": "typescript",
      "subcategory": "compilation",
      "severity": "critical",
      "confidence": "high",
      "tags": ["performance", "memory", "compilation"]
    },
    {
      "id": "typescript_performance_declaration_merging",
      "pattern": "excessive declaration merging|interface augmentation performance|module augmentation overhead",
      "type": "PerformanceError",
      "description": "Excessive declaration merging causing type checking slowdown",
      "root_cause": "declaration_merging",
      "suggestion": "Minimize interface augmentation, use explicit types instead of relying on merging",
      "category": "typescript",
      "subcategory": "types",
      "severity": "medium",
      "confidence": "medium",
      "tags": ["performance", "merging", "types"]
    },
    {
      "id": "typescript_performance_generic_inference",
      "pattern": "generic type inference.*slow|complex generic constraints|inference performance",
      "type": "PerformanceError",
      "description": "Complex generic type inference slowing compilation",
      "root_cause": "generic_complexity",
      "suggestion": "Provide explicit generic arguments, simplify generic constraints, avoid deeply nested generics",
      "category": "typescript",
      "subcategory": "generics",
      "severity": "medium",
      "confidence": "medium",
      "tags": ["performance", "generics", "inference"]
    },
    {
      "id": "typescript_performance_watch_mode",
      "pattern": "watch mode.*slow|incremental compilation.*performance|tsc --watch.*lag",
      "type": "PerformanceError",
      "description": "TypeScript watch mode performance degradation",
      "root_cause": "watch_performance",
      "suggestion": "Use project references, enable incremental compilation, exclude node_modules properly",
      "category": "typescript",
      "subcategory": "compilation",
      "severity": "medium",
      "confidence": "medium",
      "tags": ["performance", "watch", "compilation"]
    },
    {
      "id": "typescript_performance_sourcemap_generation",
      "pattern": "sourcemap.*slow|source map generation.*performance|inline source maps.*memory",
      "type": "PerformanceError",
      "description": "Source map generation affecting build performance",
      "root_cause": "sourcemap_overhead",
      "suggestion": "Use external source maps, disable source maps for production builds, use cheap-source-map for development",
      "category": "typescript",
      "subcategory": "compilation",
      "severity": "low",
      "confidence": "medium",
      "tags": ["performance", "sourcemap", "build"]
    }
  ]
}