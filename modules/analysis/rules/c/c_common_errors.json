{
  "name": "C Common Errors",
  "description": "Rules for detecting common C runtime and compilation errors",
  "rules": [
    {
      "id": "c_segmentation_fault",
      "pattern": "Segmentation fault|SIGSEGV|segfault|core dumped",
      "type": "SegmentationFault",
      "description": "Memory access violation in C program",
      "root_cause": "c_memory_access_violation",
      "suggestion": "Check for null pointer dereferences, array bounds violations, use of freed memory, or stack corruption. Use gdb or valgrind for debugging.",
      "category": "memory",
      "severity": "critical",
      "confidence": "high",
      "tags": ["c", "memory", "segfault", "runtime"],
      "examples": [
        "Segmentation fault (core dumped)",
        "Program received signal SIGSEGV"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "c_kernel_null_pointer",
      "pattern": "BUG:.*unable to handle.*NULL pointer dereference|kernel NULL pointer dereference|Oops.*NULL pointer",
      "type": "KernelNullPointerDereference",
      "description": "Kernel space null pointer dereference causing kernel panic",
      "root_cause": "kernel_null_pointer_dereference",
      "suggestion": "Check kernel module code for null pointer checks. Ensure all kernel-space pointers are validated before use. Review dmesg logs for additional context.",
      "category": "memory",
      "severity": "critical",
      "confidence": "high",
      "tags": ["c", "kernel", "null", "pointer", "panic"],
      "examples": [
        "BUG: unable to handle kernel NULL pointer dereference",
        "BUG: unable to handle kernel NULL pointer dereference at 0000000000000000"
      ],
      "metadata": {
        "context": "kernel"
      },
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "c_null_pointer_deref",
      "pattern": "null pointer|NULL pointer|dereferencing.*NULL|0x0+\\s+dereferenced",
      "type": "NullPointerDereference",
      "description": "Attempting to dereference a NULL pointer",
      "root_cause": "c_null_pointer_access",
      "suggestion": "Always check pointers for NULL before dereferencing. Initialize pointers to NULL and check after malloc/calloc.",
      "category": "memory",
      "severity": "critical",
      "confidence": "high",
      "tags": ["c", "pointer", "null", "memory"],
      "examples": [
        "dereferencing NULL pointer",
        "null pointer dereference"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "c_buffer_overflow",
      "pattern": "buffer overflow|stack smashing detected|\\*\\*\\* stack smashing detected \\*\\*\\*|buffer overrun",
      "type": "BufferOverflow",
      "description": "Writing beyond buffer boundaries",
      "root_cause": "cpp_buffer_overflow",
      "suggestion": "Use safe string functions (strncpy, snprintf). Check buffer sizes. Enable stack protection (-fstack-protector).",
      "category": "memory",
      "severity": "critical",
      "confidence": "high",
      "tags": ["c", "buffer", "overflow", "security"],
      "examples": [
        "*** stack smashing detected ***: terminated",
        "buffer overflow detected"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "c_array_bounds",
      "pattern": "array.*bounds|index.*out of (?:bounds|range)|subscript.*out of range",
      "type": "ArrayBoundsViolation",
      "description": "Array index out of bounds",
      "root_cause": "c_array_bounds_violation",
      "suggestion": "Check array indices before access. Use bounds checking. Consider using safer alternatives or bounds-checking libraries.",
      "category": "memory",
      "severity": "high",
      "confidence": "high",
      "tags": ["c", "array", "bounds", "index"],
      "examples": [
        "array index out of bounds",
        "array subscript out of range"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "c_memory_leak",
      "pattern": "memory leak|leaked \\d+ bytes|definitely lost:.*bytes|memory not freed",
      "type": "MemoryLeak",
      "description": "Dynamically allocated memory not freed",
      "root_cause": "c_memory_leak",
      "suggestion": "Ensure every malloc/calloc has corresponding free. Track allocations carefully. Use valgrind for leak detection.",
      "category": "memory",
      "severity": "high",
      "confidence": "high",
      "tags": ["c", "memory", "leak", "malloc"],
      "examples": [
        "memory leak detected",
        "definitely lost: 100 bytes in 1 blocks"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "c_double_free",
      "pattern": "double free|free\\(\\): double free|free.*already freed|corrupted double-linked list",
      "type": "DoubleFree",
      "description": "Attempting to free memory that has already been freed",
      "root_cause": "c_double_free",
      "suggestion": "Free each pointer only once. Set pointers to NULL after free. Consider using smart pointers in C++ or reference counting.",
      "category": "memory",
      "severity": "critical",
      "confidence": "high",
      "tags": ["c", "memory", "free", "corruption"],
      "examples": [
        "double free or corruption",
        "free(): double free detected"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "c_use_after_free",
      "pattern": "use[- ]after[- ]free|heap[- ]use[- ]after[- ]free|accessing freed memory",
      "type": "UseAfterFree",
      "description": "Accessing memory after it has been freed",
      "root_cause": "c_use_after_free",
      "suggestion": "Set pointers to NULL after freeing. Avoid storing pointers that may outlive the allocation.",
      "category": "memory",
      "severity": "critical",
      "confidence": "high",
      "tags": ["c", "memory", "use-after-free", "corruption"],
      "examples": [
        "heap-use-after-free",
        "use after free detected"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "c_stack_overflow",
      "pattern": "stack overflow|Stack overflow|stack exhausted|maximum recursion",
      "type": "StackOverflow",
      "description": "Stack memory exhausted",
      "root_cause": "c_stack_overflow",
      "suggestion": "Check for infinite recursion. Reduce stack usage with heap allocation for large data. Increase stack size if needed.",
      "category": "memory",
      "severity": "critical",
      "confidence": "high",
      "tags": ["c", "stack", "overflow", "recursion"],
      "examples": [
        "stack overflow detected",
        "stack exhausted"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "c_undefined_reference",
      "pattern": "undefined reference to|unresolved symbol|ld:.*undefined symbols",
      "type": "LinkerError",
      "description": "Symbol referenced but not defined during linking",
      "root_cause": "c_undefined_symbol",
      "suggestion": "Ensure all functions are implemented. Check library linking order. Include necessary libraries with -l flag.",
      "category": "memory",
      "severity": "high",
      "confidence": "high",
      "tags": ["c", "linker", "undefined", "symbol"],
      "examples": [
        "undefined reference to `function_name'",
        "ld: undefined symbols"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "c_implicit_declaration",
      "pattern": "implicit declaration of function|warning: implicit declaration|function.*not declared",
      "type": "ImplicitDeclaration",
      "description": "Function used without declaration",
      "root_cause": "c_implicit_declaration",
      "suggestion": "Include proper header files (#include <stdlib.h> for malloc/free, #include <stdio.h> for printf/scanf). Add function prototypes. Enable -Wimplicit-function-declaration.",
      "category": "compilation",
      "severity": "medium",
      "confidence": "high",
      "tags": ["c", "declaration", "function", "header"],
      "examples": [
        "implicit declaration of function 'printf'",
        "warning: implicit declaration of function"
      ],
      "metadata": {},
      "criticality": "medium",
      "complexity": "low",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "c_format_string",
      "pattern": "format.*specifier|printf.*format|scanf.*format|format string",
      "type": "FormatStringError",
      "description": "Format string mismatch with arguments",
      "root_cause": "c_format_string_error",
      "suggestion": "Match format specifiers with argument types. Use compiler warnings (-Wformat). Consider safer alternatives.",
      "category": "memory",
      "severity": "medium",
      "confidence": "high",
      "tags": ["c", "printf", "format", "string"],
      "examples": [
        "format specifier does not match argument type",
        "too few arguments for format string"
      ],
      "metadata": {},
      "criticality": "medium",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "c_division_by_zero",
      "pattern": "division by zero|divide by zero|floating point exception|FPE|arithmetic exception",
      "type": "DivisionByZero",
      "description": "Division by zero encountered",
      "root_cause": "c_division_by_zero",
      "suggestion": "Check divisor for zero before division. Handle edge cases appropriately.",
      "category": "memory",
      "severity": "high",
      "confidence": "high",
      "tags": ["c", "arithmetic", "division", "math"],
      "examples": [
        "Floating point exception (core dumped)",
        "division by zero"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "low",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "c_uninitialized_variable",
      "pattern": "uninitialized|used uninitialized|garbage value|indeterminate value",
      "type": "UninitializedVariable",
      "description": "Using uninitialized variable",
      "root_cause": "c_uninitialized_use",
      "suggestion": "Initialize all variables at declaration. Enable compiler warnings (-Wuninitialized).",
      "category": "memory",
      "severity": "high",
      "confidence": "high",
      "tags": ["c", "variable", "initialization", "undefined"],
      "examples": [
        "variable used uninitialized",
        "use of uninitialized value"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "c_type_mismatch",
      "pattern": "type mismatch|incompatible.*type|assignment.*incompatible|cannot convert",
      "type": "TypeMismatch",
      "description": "Type mismatch in assignment or function call",
      "root_cause": "c_type_mismatch",
      "suggestion": "Ensure types match in assignments and function calls. Use proper casts when necessary.",
      "category": "memory",
      "severity": "medium",
      "confidence": "high",
      "tags": ["c", "type", "mismatch", "cast"],
      "examples": [
        "incompatible types in assignment",
        "type mismatch in function call"
      ],
      "metadata": {},
      "criticality": "medium",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "c_file_not_found",
      "pattern": "No such file or directory|cannot open.*file|fopen.*failed|file not found",
      "type": "FileNotFound",
      "description": "Attempting to open non-existent file",
      "root_cause": "c_file_not_found",
      "suggestion": "Check file path and permissions. Handle fopen failures gracefully. Use absolute paths when necessary.",
      "category": "memory",
      "severity": "medium",
      "confidence": "high",
      "tags": ["c", "file", "io", "fopen"],
      "examples": [
        "No such file or directory",
        "fopen failed: No such file"
      ],
      "metadata": {},
      "criticality": "medium",
      "complexity": "low",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "c_string_null_termination",
      "pattern": "strlen.*non-null-terminated|non-null-terminated.*string|string.*not.*null.*terminated|StringError.*strlen",
      "type": "StringError",
      "description": "String function called on non-null-terminated string",
      "root_cause": "c_string_null_termination",
      "suggestion": "Ensure strings are null-terminated before using string functions. Add '\\0' at the end of buffers. Use safe string functions with bounds checking.",
      "category": "memory",
      "severity": "high",
      "confidence": "high",
      "tags": ["c", "string", "null", "termination", "strlen"],
      "examples": [
        "strlen called on non-null-terminated string",
        "string not null terminated"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    }
  ]
}