{
  "name": "C Performance Error Patterns",
  "description": "Performance optimization patterns for C applications",
  "version": "1.0.0",
  "rules": [
    {
      "id": "c_performance_malloc_in_loop",
      "pattern": "malloc.*loop|calloc.*while|realloc.*for.*loop|frequent allocation",
      "type": "PerformanceError",
      "description": "Frequent memory allocation in loop",
      "root_cause": "allocation_overhead",
      "suggestion": "Allocate memory once before loop, use memory pools, or stack allocation",
      "category": "c",
      "subcategory": "memory",
      "severity": "high",
      "confidence": "high",
      "tags": ["performance", "malloc", "loop"]
    },
    {
      "id": "c_performance_strlen_in_loop",
      "pattern": "strlen.*for.*condition|while.*strlen|loop.*length.*recalculated",
      "type": "PerformanceError",
      "description": "Calling strlen repeatedly in loop condition",
      "root_cause": "redundant_computation",
      "suggestion": "Cache string length in variable before loop",
      "category": "c",
      "subcategory": "string",
      "severity": "medium",
      "confidence": "high",
      "tags": ["performance", "strlen", "loop"]
    },
    {
      "id": "c_performance_cache_miss",
      "pattern": "cache miss|poor locality|stride.*access|column.*major.*row",
      "type": "PerformanceError",
      "description": "Poor cache locality in memory access patterns",
      "root_cause": "cache_inefficiency",
      "suggestion": "Access memory sequentially, use row-major order for matrices, consider data structure layout",
      "category": "c",
      "subcategory": "cache",
      "severity": "high",
      "confidence": "medium",
      "tags": ["performance", "cache", "memory"]
    },
    {
      "id": "c_performance_function_call_overhead",
      "pattern": "function.*call.*hot loop|indirect.*call.*performance|function pointer.*overhead",
      "type": "PerformanceError",
      "description": "Function call overhead in performance-critical code",
      "root_cause": "call_overhead",
      "suggestion": "Use inline functions, macros for simple operations, or manual inlining",
      "category": "c",
      "subcategory": "functions",
      "severity": "medium",
      "confidence": "medium",
      "tags": ["performance", "function", "overhead"]
    },
    {
      "id": "c_performance_unaligned_access",
      "pattern": "unaligned.*access|misaligned.*pointer|packed.*struct.*performance",
      "type": "PerformanceError",
      "description": "Unaligned memory access causing performance penalty",
      "root_cause": "unaligned_access",
      "suggestion": "Ensure proper alignment, use aligned allocation functions, avoid packed structs in hot paths",
      "category": "c",
      "subcategory": "memory",
      "severity": "medium",
      "confidence": "medium",
      "tags": ["performance", "alignment", "memory"]
    },
    {
      "id": "c_performance_branch_misprediction",
      "pattern": "unpredictable.*branch|random.*if.*performance|branch.*misprediction",
      "type": "PerformanceError",
      "description": "Unpredictable branches causing pipeline stalls",
      "root_cause": "branch_misprediction",
      "suggestion": "Sort data before processing, use lookup tables, consider branchless algorithms",
      "category": "c",
      "subcategory": "cpu",
      "severity": "medium",
      "confidence": "low",
      "tags": ["performance", "branch", "cpu"]
    },
    {
      "id": "c_performance_io_buffering",
      "pattern": "fgetc.*loop|fputc.*performance|unbuffered.*io|frequent.*fflush",
      "type": "PerformanceError",
      "description": "Inefficient I/O operations without proper buffering",
      "root_cause": "io_inefficiency",
      "suggestion": "Use fread/fwrite for bulk operations, setvbuf for custom buffering",
      "category": "c",
      "subcategory": "io",
      "severity": "high",
      "confidence": "high",
      "tags": ["performance", "io", "buffering"]
    },
    {
      "id": "c_performance_memory_fragmentation",
      "pattern": "fragmentation|many.*small.*allocations|heap.*fragmented",
      "type": "PerformanceError",
      "description": "Memory fragmentation from many small allocations",
      "root_cause": "memory_fragmentation",
      "suggestion": "Use memory pools, allocate larger chunks, implement custom allocator",
      "category": "c",
      "subcategory": "memory",
      "severity": "medium",
      "confidence": "medium",
      "tags": ["performance", "fragmentation", "memory"]
    },
    {
      "id": "c_performance_string_copy",
      "pattern": "strcpy.*loop|strcat.*repeated|string.*concatenation.*inefficient",
      "type": "PerformanceError",
      "description": "Inefficient string operations",
      "root_cause": "string_inefficiency",
      "suggestion": "Use memcpy when length is known, build strings in single pass",
      "category": "c",
      "subcategory": "string",
      "severity": "medium",
      "confidence": "high",
      "tags": ["performance", "string", "copy"]
    },
    {
      "id": "c_performance_floating_point",
      "pattern": "float.*integer.*comparison|double.*where.*int.*sufficient|fp.*overhead",
      "type": "PerformanceError",
      "description": "Unnecessary floating-point operations",
      "root_cause": "fp_overhead",
      "suggestion": "Use integer arithmetic where possible, consider fixed-point math",
      "category": "c",
      "subcategory": "arithmetic",
      "severity": "low",
      "confidence": "medium",
      "tags": ["performance", "float", "arithmetic"]
    },
    {
      "id": "c_performance_struct_padding",
      "pattern": "struct.*padding|wasted.*bytes|poor.*struct.*layout",
      "type": "PerformanceError",
      "description": "Inefficient struct layout causing padding waste",
      "root_cause": "struct_padding",
      "suggestion": "Reorder struct members by size (largest to smallest) to minimize padding",
      "category": "c",
      "subcategory": "memory",
      "severity": "low",
      "confidence": "medium",
      "tags": ["performance", "struct", "padding"]
    },
    {
      "id": "c_performance_division_overhead",
      "pattern": "division.*loop|divide.*by.*power.*two|modulo.*performance",
      "type": "PerformanceError",
      "description": "Integer division in performance-critical code",
      "root_cause": "division_overhead",
      "suggestion": "Use bit shifts for power-of-2 divisions, multiplication by reciprocal",
      "category": "c",
      "subcategory": "arithmetic",
      "severity": "medium",
      "confidence": "medium",
      "tags": ["performance", "division", "arithmetic"]
    },
    {
      "id": "c_performance_false_sharing",
      "pattern": "false sharing|cache line.*contention|thread.*same.*cache.*line",
      "type": "PerformanceError",
      "description": "False sharing between threads",
      "root_cause": "false_sharing",
      "suggestion": "Align thread-local data to cache line boundaries, use padding",
      "category": "c",
      "subcategory": "concurrency",
      "severity": "high",
      "confidence": "medium",
      "tags": ["performance", "threading", "cache"]
    },
    {
      "id": "c_performance_memset_small",
      "pattern": "memset.*small.*size|memset.*few.*bytes|initialization.*overhead",
      "type": "PerformanceError",
      "description": "Using memset for small memory regions",
      "root_cause": "memset_overhead",
      "suggestion": "Use direct assignment for small structs, = {0} for initialization",
      "category": "c",
      "subcategory": "memory",
      "severity": "low",
      "confidence": "medium",
      "tags": ["performance", "memset", "initialization"]
    },
    {
      "id": "c_performance_qsort_small",
      "pattern": "qsort.*small.*array|sorting.*few.*elements|sort.*overhead",
      "type": "PerformanceError",
      "description": "Using qsort for small arrays",
      "root_cause": "sort_overhead",
      "suggestion": "Use insertion sort for small arrays (< 10-20 elements)",
      "category": "c",
      "subcategory": "algorithm",
      "severity": "low",
      "confidence": "medium",
      "tags": ["performance", "sort", "algorithm"]
    }
  ]
}