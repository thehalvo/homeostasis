{
  "name": "C++ Common Errors",
  "description": "Rules for detecting common C++ runtime and compilation errors",
  "rules": [
    {
      "id": "cpp_segmentation_fault",
      "pattern": "Segmentation fault|SIGSEGV|segfault",
      "type": "SegmentationFault",
      "description": "Memory access violation, typically accessing invalid memory",
      "root_cause": "cpp_memory_access_violation",
      "suggestion": "Check for null pointer dereferences, array bounds violations, use-after-free errors, or stack corruption. Use debugging tools like gdb or valgrind.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "memory", "segfault", "runtime"],
      "examples": [
        "Segmentation fault (core dumped)",
        "Program received signal SIGSEGV, Segmentation fault"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_kernel_null_pointer",
      "pattern": "BUG:.*unable to handle.*NULL pointer dereference|kernel NULL pointer dereference|Oops.*NULL pointer",
      "type": "KernelNullPointerDereference",
      "description": "Kernel space null pointer dereference causing kernel panic",
      "root_cause": "kernel_null_pointer_dereference",
      "suggestion": "Check kernel module code for null pointer checks. Ensure all kernel-space pointers are validated before use. Review dmesg logs for additional context.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "kernel", "null", "pointer", "panic"],
      "examples": [
        "BUG: unable to handle kernel NULL pointer dereference",
        "BUG: unable to handle kernel NULL pointer dereference at 0000000000000000"
      ],
      "metadata": {
        "context": "kernel"
      },
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_null_pointer_deref",
      "pattern": "(?:dereferencing|dereference).*null pointer|nullptr dereference|0x0+\\s+(?:dereferenced|accessed)",
      "type": "NullPointerDereference",
      "description": "Attempting to dereference a null pointer",
      "root_cause": "cpp_null_pointer_access",
      "suggestion": "Always check pointers for nullptr before dereferencing. Use smart pointers (unique_ptr, shared_ptr) to manage memory safely.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "pointer", "null", "memory"],
      "examples": [
        "dereferencing null pointer",
        "nullptr dereference detected"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_array_out_of_bounds",
      "pattern": "(?:array|vector|buffer)\\s+(?:index|subscript)\\s+out of (?:bounds|range)|std::out_of_range",
      "type": "ArrayOutOfBounds",
      "description": "Accessing array or container element outside valid range",
      "root_cause": "cpp_array_bounds_violation",
      "suggestion": "Check array indices before access. Use at() method for bounds-checked access in STL containers. Consider using std::array or std::vector instead of raw arrays.",
      "category": "cpp",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "array", "bounds", "container"],
      "examples": [
        "array index out of bounds",
        "vector subscript out of range",
        "std::out_of_range exception"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_memory_leak",
      "pattern": "memory leak|leaked \\d+ bytes|definitely lost: \\d+ bytes",
      "type": "MemoryLeak",
      "description": "Dynamically allocated memory not freed",
      "root_cause": "cpp_memory_leak",
      "suggestion": "Ensure every new/malloc has corresponding delete/free. Use RAII and smart pointers (unique_ptr, shared_ptr) to automatically manage memory.",
      "category": "cpp",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "memory", "leak", "allocation"],
      "examples": [
        "memory leak detected",
        "definitely lost: 1,024 bytes in 1 blocks"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_double_free",
      "pattern": "double free|free\\(\\): double free detected|corrupted double-linked list",
      "type": "DoubleFree",
      "description": "Attempting to free memory that has already been freed",
      "root_cause": "cpp_double_free",
      "suggestion": "Set pointers to nullptr after delete/free. Use smart pointers to avoid manual memory management. Track ownership carefully.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "memory", "free", "corruption"],
      "examples": [
        "double free or corruption",
        "free(): double free detected in tcache"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_use_after_free",
      "pattern": "use[- ]after[- ]free|heap[- ]use[- ]after[- ]free|accessing freed memory",
      "type": "UseAfterFree",
      "description": "Accessing memory after it has been freed",
      "root_cause": "cpp_use_after_free",
      "suggestion": "Set pointers to nullptr after freeing. Use smart pointers. Avoid storing raw pointers that may outlive the object.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "memory", "use-after-free", "corruption"],
      "examples": [
        "heap-use-after-free",
        "use after free detected"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_stack_overflow",
      "pattern": "stack overflow|Stack overflow|maximum recursion depth exceeded|stack smashing detected",
      "type": "StackOverflow",
      "description": "Stack memory exhausted, often due to infinite recursion",
      "root_cause": "cpp_stack_overflow",
      "suggestion": "Check for infinite recursion. Reduce stack usage by using heap allocation for large objects. Increase stack size if necessary.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "stack", "overflow", "recursion"],
      "examples": [
        "stack overflow detected",
        "*** stack smashing detected ***: terminated"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_undefined_reference",
      "pattern": "undefined reference to|unresolved external symbol",
      "type": "LinkerError",
      "description": "Symbol referenced but not defined during linking",
      "root_cause": "cpp_undefined_symbol",
      "suggestion": "Ensure all declared functions are implemented. Check library linking order. Verify all required libraries are linked.",
      "category": "cpp",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "linker", "undefined", "symbol"],
      "examples": [
        "undefined reference to `main'",
        "undefined reference to `MyClass::myMethod()'"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_pure_virtual_call",
      "pattern": "pure virtual (?:function|method) called|Pure virtual function called",
      "type": "PureVirtualCall",
      "description": "Pure virtual function called, typically during object construction/destruction",
      "root_cause": "cpp_pure_virtual_call",
      "suggestion": "Avoid calling virtual functions from constructors/destructors. Ensure objects are fully constructed before use.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "virtual", "inheritance", "runtime"],
      "examples": [
        "pure virtual method called",
        "Pure virtual function called!"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_bad_alloc",
      "pattern": "std::bad_alloc|bad_alloc|bad allocation|cannot allocate memory",
      "type": "BadAlloc",
      "description": "Memory allocation failed, typically due to insufficient memory",
      "root_cause": "cpp_allocation_failure",
      "suggestion": "Check available memory. Catch std::bad_alloc exceptions. Consider using nothrow versions of new. Reduce memory usage.",
      "category": "cpp",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "memory", "allocation", "exception"],
      "examples": [
        "std::bad_alloc",
        "terminate called after throwing an instance of 'std::bad_alloc'"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_invalid_cast",
      "pattern": "bad_cast|std::bad_cast|dynamic_cast.*failed|invalid cast",
      "type": "InvalidCast",
      "description": "Type cast failed, typically with dynamic_cast",
      "root_cause": "cpp_invalid_type_cast",
      "suggestion": "Verify object types before casting. Use dynamic_cast with polymorphic types only. Check cast results for nullptr.",
      "category": "cpp",
      "severity": "medium",
      "confidence": "high",
      "tags": ["cpp", "cast", "type", "rtti"],
      "examples": [
        "std::bad_cast",
        "dynamic_cast failed"
      ],
      "metadata": {},
      "criticality": "medium",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_iterator_invalidation",
      "pattern": "iterator.*invalidated|invalid iterator|Iterator.*not dereferenceable",
      "type": "IteratorInvalidation",
      "description": "Using an iterator after it has been invalidated",
      "root_cause": "cpp_iterator_invalidation",
      "suggestion": "Be aware of operations that invalidate iterators (insert, erase, etc.). Re-obtain iterators after container modifications.",
      "category": "cpp",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "iterator", "stl", "container"],
      "examples": [
        "iterator invalidated",
        "vector iterator not dereferenceable"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_division_by_zero",
      "pattern": "(?:floating point exception|division by zero|divide by zero|FPE)",
      "type": "DivisionByZero",
      "description": "Division by zero encountered",
      "root_cause": "cpp_division_by_zero",
      "suggestion": "Check divisor for zero before division operations. Handle edge cases appropriately.",
      "category": "cpp",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "arithmetic", "division", "math"],
      "examples": [
        "Floating point exception (core dumped)",
        "division by zero"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "low",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_deadlock",
      "pattern": "deadlock.*detected|Resource deadlock|mutex.*deadlock|circular lock dependency",
      "type": "Deadlock",
      "description": "Deadlock detected in multi-threaded code",
      "root_cause": "cpp_deadlock",
      "suggestion": "Always acquire locks in the same order. Use std::lock() for multiple mutexes. Consider lock-free alternatives.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "threading", "deadlock", "mutex"],
      "examples": [
        "Resource deadlock avoided",
        "deadlock detected"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_race_condition",
      "pattern": "data race|race condition|ThreadSanitizer.*race",
      "type": "RaceCondition",
      "description": "Race condition detected in concurrent access",
      "root_cause": "cpp_race_condition",
      "suggestion": "Use proper synchronization (mutexes, atomics). Protect shared data. Consider thread-safe alternatives.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "threading", "race", "concurrency"],
      "examples": [
        "WARNING: ThreadSanitizer: data race",
        "race condition detected"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_hardware_fault",
      "pattern": "hard fault|hardware fault|HardwareFault",
      "type": "HardwareFault",
      "description": "Hardware fault detected in embedded system",
      "root_cause": "cpp_hardware_fault",
      "suggestion": "Check stack pointer for overflow, verify memory access patterns, review interrupt handlers, check for invalid memory regions",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "hardware", "fault", "embedded", "runtime"],
      "examples": [
        "Hard fault handler triggered",
        "Hardware fault exception"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_implicit_declaration",
      "pattern": "implicit declaration of function",
      "type": "ImplicitDeclaration",
      "description": "Function used without proper declaration or missing header",
      "root_cause": "cpp_implicit_declaration",
      "suggestion": "Include proper header files (#include <cstdlib> or <stdlib.h> for malloc/free, #include <cstdio> or <stdio.h> for printf/scanf). Add function prototypes.",
      "category": "compilation",
      "severity": "medium",
      "confidence": "high",
      "tags": ["cpp", "c", "compilation", "header", "declaration"],
      "examples": [
        "warning: implicit declaration of function 'malloc'",
        "implicit declaration of function 'printf'"
      ],
      "metadata": {},
      "criticality": "medium",
      "complexity": "low",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_void_pointer_arithmetic",
      "pattern": "void\\s*\\*.*used in arithmetic|arithmetic.*void\\s*(pointer|\\*)|pointer of type.*void.*used in arithmetic",
      "type": "VoidPointerArithmetic",
      "description": "Arithmetic on void pointers is not allowed in standard C/C++",
      "root_cause": "cpp_void_pointer_arithmetic",
      "suggestion": "Cast the void pointer to the appropriate type before performing arithmetic. For example: (char*)ptr + 1",
      "category": "compilation",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "c", "pointer", "void", "arithmetic"],
      "examples": [
        "error: pointer of type 'void *' used in arithmetic",
        "arithmetic on a pointer to void"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "low",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_array_decay",
      "pattern": "sizeof on array function parameter|array.*decay.*pointer|will return size of pointer",
      "type": "ArrayDecay",
      "description": "Array parameter decays to pointer in function",
      "root_cause": "cpp_array_decay_to_pointer",
      "suggestion": "Pass array size as a separate parameter or use a structure/template to preserve array size information",
      "category": "cpp",
      "severity": "medium",
      "confidence": "high",
      "tags": ["cpp", "c", "array", "pointer", "sizeof", "decay"],
      "examples": [
        "warning: sizeof on array function parameter will return size of pointer",
        "array decays to pointer"
      ],
      "metadata": {},
      "criticality": "medium",
      "complexity": "low",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_null_pointer_dereference",
      "pattern": "Segmentation fault|SIGSEGV|address.*0x0|null pointer dereference",
      "type": "NullPointerDereference",
      "description": "Null pointer dereference causing segmentation fault",
      "root_cause": "cpp_null_pointer_dereference",
      "suggestion": "Add null pointer checks before dereferencing pointers. Use defensive programming techniques.",
      "category": "runtime",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "c", "null", "pointer", "segfault", "runtime"],
      "examples": [
        "Segmentation fault",
        "SIGSEGV",
        "dereferencing null pointer"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "low",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_format_string_vulnerability",
      "pattern": "format string.*vulnerability|printf.*user.*input|format.*not.*literal|non-literal format string",
      "type": "FormatStringVulnerability",
      "description": "Format string vulnerability - user input used as format string",
      "root_cause": "cpp_format_string_vulnerability",
      "suggestion": "Never use user input as format string. Use printf(\"%s\", user_input) instead of printf(user_input)",
      "category": "security",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "c", "security", "format", "printf", "vulnerability"],
      "examples": [
        "warning: format string is not a string literal",
        "format string vulnerability"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "low",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_malloc_failure",
      "pattern": "malloc failed|Cannot allocate memory|allocation failed|out of memory",
      "type": "MemoryAllocationError",
      "description": "Memory allocation failure - malloc/calloc/realloc failed",
      "root_cause": "cpp_memory_allocation_failure",
      "suggestion": "Check malloc return value for NULL before using. Consider reducing memory requirements or using memory pools. Always handle allocation failures gracefully.",
      "category": "memory",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "c", "memory", "malloc", "allocation"],
      "examples": [
        "malloc failed: Cannot allocate memory",
        "out of memory"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "medium",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_use_after_free",
      "pattern": "use.after.free|heap use after free|UseAfterFree|freed memory|dangling pointer",
      "type": "UseAfterFree",
      "description": "Accessing memory after it has been freed",
      "root_cause": "cpp_use_after_free",
      "suggestion": "Set pointers to NULL after freeing. Use defensive programming to check pointer validity. Consider using smart pointers or reference counting.",
      "category": "memory",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "c", "memory", "heap", "security"],
      "examples": [
        "heap use after free",
        "use-after-free detected"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_memory_leak",
      "pattern": "memory leak|definitely lost|possibly lost|still reachable|MemoryLeak|valgrind.*lost",
      "type": "MemoryLeak",
      "description": "Memory allocated but not freed",
      "root_cause": "cpp_memory_leak",
      "suggestion": "Ensure every malloc/calloc has a corresponding free. Use RAII pattern or smart pointers. Track allocations and implement proper cleanup in error paths.",
      "category": "memory",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "c", "memory", "leak", "valgrind"],
      "examples": [
        "definitely lost: 100 bytes in 1 blocks",
        "memory leak detected"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "medium",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_buffer_overflow",
      "pattern": "buffer overflow|stack buffer overflow|heap buffer overflow|StackBufferOverflow|buffer overrun",
      "type": "BufferOverflow",
      "description": "Writing beyond buffer boundaries",
      "root_cause": "cpp_buffer_overflow",
      "suggestion": "Always check buffer bounds before writing. Use safe string functions (strncpy, snprintf). Consider using std::vector or std::array in C++.",
      "category": "memory",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "c", "memory", "buffer", "security", "overflow"],
      "examples": [
        "stack buffer overflow",
        "buffer overflow detected"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_file_operation_error",
      "pattern": "fopen failed|FileOperationError|No such file or directory|Permission denied|file.*error",
      "type": "FileOperationError",
      "description": "File operation failed",
      "root_cause": "cpp_file_operation_error",
      "suggestion": "Check file existence and permissions before opening. Always check fopen return value for NULL. Use errno/perror for detailed error information.",
      "category": "io",
      "severity": "medium",
      "confidence": "high",
      "tags": ["cpp", "c", "file", "io", "fopen"],
      "examples": [
        "fopen failed: No such file or directory",
        "file operation error"
      ],
      "metadata": {},
      "criticality": "medium",
      "complexity": "low",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_division_by_zero",
      "pattern": "division by zero|divide by zero|DivisionByZero|arithmetic exception.*div.*zero",
      "type": "DivisionByZero",
      "description": "Division by zero arithmetic error",
      "root_cause": "cpp_division_by_zero",
      "suggestion": "Always check divisor for zero before division. Use defensive programming. Consider using floating point with infinity handling.",
      "category": "arithmetic",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "c", "arithmetic", "division", "runtime"],
      "examples": [
        "division by zero",
        "arithmetic exception: divide by zero"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "low",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_string_function_misuse",
      "pattern": "string.*error|strcpy.*dangerous|gets.*unsafe|buffer.*string|StringFunctionMisuse",
      "type": "StringFunctionMisuse",
      "description": "Unsafe or incorrect string function usage",
      "root_cause": "cpp_string_function_misuse",
      "suggestion": "Use safe string functions: strncpy instead of strcpy, fgets instead of gets, snprintf instead of sprintf. Always ensure null termination.",
      "category": "string",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "c", "string", "security", "buffer"],
      "examples": [
        "strcpy is dangerous",
        "string function misuse"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "medium",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    }
  ]
}