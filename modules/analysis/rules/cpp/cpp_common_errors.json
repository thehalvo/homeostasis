{
  "name": "C++ Common Errors",
  "description": "Rules for detecting common C++ runtime and compilation errors",
  "rules": [
    {
      "id": "cpp_segmentation_fault",
      "pattern": "Segmentation fault|SIGSEGV|segfault",
      "type": "SegmentationFault",
      "description": "Memory access violation, typically accessing invalid memory",
      "root_cause": "cpp_memory_access_violation",
      "suggestion": "Check for null pointer dereferences, array bounds violations, use-after-free errors, or stack corruption. Use debugging tools like gdb or valgrind.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "memory", "segfault", "runtime"],
      "examples": [
        "Segmentation fault (core dumped)",
        "Program received signal SIGSEGV, Segmentation fault"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_null_pointer_deref",
      "pattern": "(?:dereferencing|dereference).*null pointer|nullptr dereference|0x0+\\s+(?:dereferenced|accessed)",
      "type": "NullPointerDereference",
      "description": "Attempting to dereference a null pointer",
      "root_cause": "cpp_null_pointer_access",
      "suggestion": "Always check pointers for nullptr before dereferencing. Use smart pointers (unique_ptr, shared_ptr) to manage memory safely.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "pointer", "null", "memory"],
      "examples": [
        "dereferencing null pointer",
        "nullptr dereference detected"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_array_out_of_bounds",
      "pattern": "(?:array|vector|buffer)\\s+(?:index|subscript)\\s+out of (?:bounds|range)|std::out_of_range",
      "type": "ArrayOutOfBounds",
      "description": "Accessing array or container element outside valid range",
      "root_cause": "cpp_array_bounds_violation",
      "suggestion": "Check array indices before access. Use at() method for bounds-checked access in STL containers. Consider using std::array or std::vector instead of raw arrays.",
      "category": "cpp",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "array", "bounds", "container"],
      "examples": [
        "array index out of bounds",
        "vector subscript out of range",
        "std::out_of_range exception"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_memory_leak",
      "pattern": "memory leak|leaked \\d+ bytes|definitely lost: \\d+ bytes",
      "type": "MemoryLeak",
      "description": "Dynamically allocated memory not freed",
      "root_cause": "cpp_memory_leak",
      "suggestion": "Ensure every new/malloc has corresponding delete/free. Use RAII and smart pointers (unique_ptr, shared_ptr) to automatically manage memory.",
      "category": "cpp",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "memory", "leak", "allocation"],
      "examples": [
        "memory leak detected",
        "definitely lost: 1,024 bytes in 1 blocks"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_double_free",
      "pattern": "double free|free\\(\\): double free detected|corrupted double-linked list",
      "type": "DoubleFree",
      "description": "Attempting to free memory that has already been freed",
      "root_cause": "cpp_double_free",
      "suggestion": "Set pointers to nullptr after delete/free. Use smart pointers to avoid manual memory management. Track ownership carefully.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "memory", "free", "corruption"],
      "examples": [
        "double free or corruption",
        "free(): double free detected in tcache"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_use_after_free",
      "pattern": "use[- ]after[- ]free|heap[- ]use[- ]after[- ]free|accessing freed memory",
      "type": "UseAfterFree",
      "description": "Accessing memory after it has been freed",
      "root_cause": "cpp_use_after_free",
      "suggestion": "Set pointers to nullptr after freeing. Use smart pointers. Avoid storing raw pointers that may outlive the object.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "memory", "use-after-free", "corruption"],
      "examples": [
        "heap-use-after-free",
        "use after free detected"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_stack_overflow",
      "pattern": "stack overflow|Stack overflow|maximum recursion depth exceeded|stack smashing detected",
      "type": "StackOverflow",
      "description": "Stack memory exhausted, often due to infinite recursion",
      "root_cause": "cpp_stack_overflow",
      "suggestion": "Check for infinite recursion. Reduce stack usage by using heap allocation for large objects. Increase stack size if necessary.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "stack", "overflow", "recursion"],
      "examples": [
        "stack overflow detected",
        "*** stack smashing detected ***: terminated"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_undefined_reference",
      "pattern": "undefined reference to|unresolved external symbol",
      "type": "LinkerError",
      "description": "Symbol referenced but not defined during linking",
      "root_cause": "cpp_undefined_symbol",
      "suggestion": "Ensure all declared functions are implemented. Check library linking order. Verify all required libraries are linked.",
      "category": "cpp",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "linker", "undefined", "symbol"],
      "examples": [
        "undefined reference to `main'",
        "undefined reference to `MyClass::myMethod()'"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_pure_virtual_call",
      "pattern": "pure virtual (?:function|method) called|Pure virtual function called",
      "type": "PureVirtualCall",
      "description": "Pure virtual function called, typically during object construction/destruction",
      "root_cause": "cpp_pure_virtual_call",
      "suggestion": "Avoid calling virtual functions from constructors/destructors. Ensure objects are fully constructed before use.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "virtual", "inheritance", "runtime"],
      "examples": [
        "pure virtual method called",
        "Pure virtual function called!"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_bad_alloc",
      "pattern": "std::bad_alloc|bad_alloc|bad allocation|cannot allocate memory",
      "type": "BadAlloc",
      "description": "Memory allocation failed, typically due to insufficient memory",
      "root_cause": "cpp_allocation_failure",
      "suggestion": "Check available memory. Catch std::bad_alloc exceptions. Consider using nothrow versions of new. Reduce memory usage.",
      "category": "cpp",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "memory", "allocation", "exception"],
      "examples": [
        "std::bad_alloc",
        "terminate called after throwing an instance of 'std::bad_alloc'"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_invalid_cast",
      "pattern": "bad_cast|std::bad_cast|dynamic_cast.*failed|invalid cast",
      "type": "InvalidCast",
      "description": "Type cast failed, typically with dynamic_cast",
      "root_cause": "cpp_invalid_type_cast",
      "suggestion": "Verify object types before casting. Use dynamic_cast with polymorphic types only. Check cast results for nullptr.",
      "category": "cpp",
      "severity": "medium",
      "confidence": "high",
      "tags": ["cpp", "cast", "type", "rtti"],
      "examples": [
        "std::bad_cast",
        "dynamic_cast failed"
      ],
      "metadata": {},
      "criticality": "medium",
      "complexity": "moderate",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_iterator_invalidation",
      "pattern": "iterator.*invalidated|invalid iterator|Iterator.*not dereferenceable",
      "type": "IteratorInvalidation",
      "description": "Using an iterator after it has been invalidated",
      "root_cause": "cpp_iterator_invalidation",
      "suggestion": "Be aware of operations that invalidate iterators (insert, erase, etc.). Re-obtain iterators after container modifications.",
      "category": "cpp",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "iterator", "stl", "container"],
      "examples": [
        "iterator invalidated",
        "vector iterator not dereferenceable"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_division_by_zero",
      "pattern": "(?:floating point exception|division by zero|divide by zero|FPE)",
      "type": "DivisionByZero",
      "description": "Division by zero encountered",
      "root_cause": "cpp_division_by_zero",
      "suggestion": "Check divisor for zero before division operations. Handle edge cases appropriately.",
      "category": "cpp",
      "severity": "high",
      "confidence": "high",
      "tags": ["cpp", "arithmetic", "division", "math"],
      "examples": [
        "Floating point exception (core dumped)",
        "division by zero"
      ],
      "metadata": {},
      "criticality": "high",
      "complexity": "low",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_deadlock",
      "pattern": "deadlock.*detected|Resource deadlock|mutex.*deadlock|circular lock dependency",
      "type": "Deadlock",
      "description": "Deadlock detected in multi-threaded code",
      "root_cause": "cpp_deadlock",
      "suggestion": "Always acquire locks in the same order. Use std::lock() for multiple mutexes. Consider lock-free alternatives.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "threading", "deadlock", "mutex"],
      "examples": [
        "Resource deadlock avoided",
        "deadlock detected"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    },
    {
      "id": "cpp_race_condition",
      "pattern": "data race|race condition|ThreadSanitizer.*race",
      "type": "RaceCondition",
      "description": "Race condition detected in concurrent access",
      "root_cause": "cpp_race_condition",
      "suggestion": "Use proper synchronization (mutexes, atomics). Protect shared data. Consider thread-safe alternatives.",
      "category": "cpp",
      "severity": "critical",
      "confidence": "high",
      "tags": ["cpp", "threading", "race", "concurrency"],
      "examples": [
        "WARNING: ThreadSanitizer: data race",
        "race condition detected"
      ],
      "metadata": {},
      "criticality": "critical",
      "complexity": "high",
      "reliability": "high",
      "source": "built_in",
      "rule_type": "error_detection",
      "dependencies": []
    }
  ]
}