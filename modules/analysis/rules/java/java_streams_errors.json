{
  "description": "Java streams, lambdas, and functional programming error detection rules",
  "version": "1.0.0",
  "rules": [
    {
      "id": "java_stream_already_operated",
      "pattern": "stream has already been operated upon or closed|IllegalStateException.*stream",
      "error_type": "StreamAlreadyOperatedException",
      "description": "Stream has already been consumed or closed",
      "root_cause": "java_stream_reuse",
      "suggestion": "Streams can only be used once and cannot be reused. Create a new stream for each terminal operation. Use Supplier<Stream> for reusable stream creation.",
      "confidence": "high",
      "severity": "high",
      "category": "streams",
      "framework": "java"
    },
    {
      "id": "java_parallel_stream_race",
      "pattern": "ConcurrentModificationException.*parallel|thread-safety.*stream|race condition.*parallel",
      "error_type": "ParallelStreamRaceCondition",
      "description": "Race condition in parallel stream operation",
      "root_cause": "java_parallel_stream_race",
      "suggestion": "Ensure stream operations are stateless and thread-safe. Avoid modifying shared state in parallel streams. Use concurrent collections or synchronization.",
      "confidence": "high",
      "severity": "high",
      "category": "streams",
      "framework": "java"
    },
    {
      "id": "java_stream_null_pointer",
      "pattern": "NullPointerException.*stream|Cannot invoke.*on null.*Stream",
      "error_type": "StreamNullPointerException",
      "description": "Null value encountered in stream operation",
      "root_cause": "java_stream_null",
      "suggestion": "Filter out nulls with .filter(Objects::nonNull) or use Optional. Check collection isn't null before creating stream.",
      "confidence": "high",
      "severity": "high",
      "category": "streams",
      "framework": "java"
    },
    {
      "id": "java_collector_compatibility",
      "pattern": "collector.*incompatible types|wrong number of arguments.*Collector|cannot collect",
      "error_type": "CollectorCompatibilityError",
      "description": "Incompatible collector for stream type",
      "root_cause": "java_collector_error",
      "suggestion": "Ensure collector matches stream element type. Check Collectors.toMap() key/value functions. Use appropriate downstream collectors.",
      "confidence": "high",
      "severity": "medium",
      "category": "streams",
      "framework": "java"
    },
    {
      "id": "java_reduce_identity_error",
      "pattern": "identity value.*must be.*identity|reduce.*wrong identity|accumulator.*inconsistent",
      "error_type": "ReduceIdentityError",
      "description": "Invalid identity value for reduce operation",
      "root_cause": "java_reduce_identity",
      "suggestion": "Identity must be neutral element: 0 for sum, 1 for product, empty for concatenation. Ensure accumulator is associative.",
      "confidence": "medium",
      "severity": "medium",
      "category": "streams",
      "framework": "java"
    },
    {
      "id": "java_lambda_exception",
      "pattern": "unhandled exception.*lambda|exception.*not compatible with.*functional interface|checked exception.*lambda",
      "error_type": "LambdaCheckedException",
      "description": "Checked exception in lambda expression",
      "root_cause": "java_lambda_exception",
      "suggestion": "Wrap checked exceptions in unchecked ones or use try-catch inside lambda. Consider creating wrapper methods for exception handling.",
      "confidence": "high",
      "severity": "medium",
      "category": "streams",
      "framework": "java"
    },
    {
      "id": "java_optional_misuse",
      "pattern": "NoSuchElementException.*Optional\\.get|Optional\\.get\\(\\).*empty|calling get\\(\\) on empty",
      "error_type": "OptionalMisuse",
      "description": "Calling get() on empty Optional",
      "root_cause": "java_optional_misuse",
      "suggestion": "Use Optional.isPresent() before get(), or preferably use orElse(), orElseGet(), orElseThrow(), or ifPresent().",
      "confidence": "high",
      "severity": "high",
      "category": "streams",
      "framework": "java"
    },
    {
      "id": "java_stream_ordering_assumption",
      "pattern": "findFirst.*unordered|ordering.*not guaranteed|parallel.*order dependent",
      "error_type": "StreamOrderingAssumption",
      "description": "Assuming ordering in unordered stream operations",
      "root_cause": "java_stream_ordering",
      "suggestion": "Use forEachOrdered() instead of forEach() for order. Be aware parallel() may affect ordering. Use sorted() if order matters.",
      "confidence": "medium",
      "severity": "medium",
      "category": "streams",
      "framework": "java"
    },
    {
      "id": "java_infinite_stream",
      "pattern": "OutOfMemoryError.*Stream|infinite stream.*terminal|stream.*does not terminate",
      "error_type": "InfiniteStreamError",
      "description": "Infinite stream without proper termination",
      "root_cause": "java_infinite_stream",
      "suggestion": "Use limit() with infinite streams (Stream.generate, Stream.iterate). Ensure terminal operations can complete.",
      "confidence": "medium",
      "severity": "high",
      "category": "streams",
      "framework": "java"
    },
    {
      "id": "java_lambda_variable_capture",
      "pattern": "local variables referenced from.*lambda.*must be final|effectively final|cannot assign.*lambda",
      "error_type": "LambdaVariableCapture",
      "description": "Modifying variables captured by lambda",
      "root_cause": "java_lambda_capture",
      "suggestion": "Variables used in lambdas must be final or effectively final. Use AtomicReference or array wrapper for mutable state.",
      "confidence": "high",
      "severity": "high",
      "category": "streams",
      "framework": "java"
    },
    {
      "id": "java_method_reference_ambiguity",
      "pattern": "ambiguous method reference|reference.*is ambiguous|both.*match",
      "error_type": "MethodReferenceAmbiguity",
      "description": "Ambiguous method reference",
      "root_cause": "java_method_ref_ambiguous",
      "suggestion": "Use explicit lambda instead of method reference, or cast to specific functional interface type.",
      "confidence": "medium",
      "severity": "medium",
      "category": "streams",
      "framework": "java"
    },
    {
      "id": "java_collector_duplicate_key",
      "pattern": "Duplicate key.*Collectors\\.toMap|key.*already mapped|IllegalStateException.*duplicate",
      "error_type": "CollectorDuplicateKey",
      "description": "Duplicate keys in Collectors.toMap()",
      "root_cause": "java_collector_duplicate_key",
      "suggestion": "Provide merge function as third parameter to toMap() to handle duplicates, or use groupingBy() for multiple values per key.",
      "confidence": "high",
      "severity": "high",
      "category": "streams",
      "framework": "java"
    },
    {
      "id": "java_stream_side_effects",
      "pattern": "side-effects.*stream|stateful.*operation|modifying.*during iteration",
      "error_type": "StreamSideEffects",
      "description": "Side effects in stream operations",
      "root_cause": "java_stream_side_effects",
      "suggestion": "Keep stream operations pure and stateless. Use collect() for mutable reductions. Avoid peek() for critical operations.",
      "confidence": "medium",
      "severity": "medium",
      "category": "streams",
      "framework": "java"
    },
    {
      "id": "java_flatmap_type_error",
      "pattern": "incompatible types.*flatMap|cannot convert.*Stream|flatMap.*requires.*Stream",
      "error_type": "FlatMapTypeError",
      "description": "Type error in flatMap operation",
      "root_cause": "java_flatmap_type_error",
      "suggestion": "flatMap function must return a Stream. Use map() for one-to-one transformations, flatMap() for one-to-many.",
      "confidence": "high",
      "severity": "medium",
      "category": "streams",
      "framework": "java"
    },
    {
      "id": "java_stream_performance",
      "pattern": "performance.*stream|stream.*overhead|unnecessary.*boxing|stream.*slow",
      "error_type": "StreamPerformanceIssue",
      "description": "Performance issue with stream usage",
      "root_cause": "java_stream_performance",
      "suggestion": "Use primitive streams (IntStream, LongStream) to avoid boxing. Consider traditional loops for simple operations. Profile parallel vs sequential.",
      "confidence": "low",
      "severity": "low",
      "category": "streams",
      "framework": "java"
    }
  ]
}