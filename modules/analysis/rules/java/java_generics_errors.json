{
  "description": "Java generics and type system error detection rules for advanced type features",
  "version": "1.0.0",
  "rules": [
    {
      "id": "java_unchecked_cast_warning",
      "pattern": "unchecked cast|Type safety: Unchecked cast from|uses unchecked or unsafe operations",
      "error_type": "UncheckedCast",
      "description": "Unchecked cast that may cause ClassCastException at runtime",
      "root_cause": "java_unchecked_cast",
      "suggestion": "Use proper generic types to avoid unchecked casts. If unavoidable, validate types before casting or use @SuppressWarnings(\"unchecked\") with caution.",
      "confidence": "high",
      "severity": "medium",
      "category": "generics",
      "framework": "java"
    },
    {
      "id": "java_raw_type_usage",
      "pattern": "found\\s+raw\\s+type|Raw use of parameterized class|is a raw type\\. References to generic type",
      "error_type": "RawTypeUsage",
      "description": "Using raw types instead of parameterized types, losing type safety",
      "root_cause": "java_raw_type",
      "suggestion": "Specify generic type parameters, e.g., use List<String> instead of List. Update legacy code to use generics for type safety.",
      "confidence": "high",
      "severity": "medium",
      "category": "generics",
      "framework": "java"
    },
    {
      "id": "java_type_parameter_bounds_error",
      "pattern": "type parameter .* is not within its bound|does not satisfy the constraint|incompatible types: .* cannot be converted to",
      "error_type": "TypeParameterBoundsError",
      "description": "Type parameter does not satisfy its declared bounds",
      "root_cause": "java_type_bounds_error",
      "suggestion": "Ensure type arguments satisfy all declared bounds. Check extends/super wildcards. Review generic method/class constraints.",
      "confidence": "high",
      "severity": "high",
      "category": "generics",
      "framework": "java"
    },
    {
      "id": "java_generic_array_creation",
      "pattern": "generic array creation|Cannot create a generic array of|array creation not allowed with generic types",
      "error_type": "GenericArrayCreation",
      "description": "Attempting to create arrays of generic types, which is not allowed",
      "root_cause": "java_generic_array_error",
      "suggestion": "Use Collections (List<T>) instead of arrays for generic types. If arrays are necessary, use Object[] and cast carefully, or use Array.newInstance().",
      "confidence": "high",
      "severity": "high",
      "category": "generics",
      "framework": "java"
    },
    {
      "id": "java_type_erasure_conflict",
      "pattern": "name clash|have the same erasure|method .* cannot be applied to given types",
      "error_type": "TypeErasureConflict",
      "description": "Methods or classes conflict due to type erasure",
      "root_cause": "java_type_erasure",
      "suggestion": "Rename conflicting methods or use different parameter types. Understand type erasure: List<String> and List<Integer> have same runtime type.",
      "confidence": "high",
      "severity": "high",
      "category": "generics",
      "framework": "java"
    },
    {
      "id": "java_wildcard_capture_error",
      "pattern": "capture of \\?|wildcard capture|incompatible types: .* cannot be converted to capture",
      "error_type": "WildcardCaptureError",
      "description": "Wildcard type capture issues preventing type inference",
      "root_cause": "java_wildcard_capture",
      "suggestion": "Use helper methods to capture wildcard types. Consider using bounded wildcards (? extends T or ? super T) or concrete types.",
      "confidence": "medium",
      "severity": "medium",
      "category": "generics",
      "framework": "java"
    },
    {
      "id": "java_variance_error",
      "pattern": "incompatible types: .* cannot be converted to .*<?|contravariance|covariance violation",
      "error_type": "VarianceError",
      "description": "Covariance or contravariance violation in generic types",
      "root_cause": "java_variance_error",
      "suggestion": "Use PECS principle: Producer Extends, Consumer Super. For reading use ? extends T, for writing use ? super T.",
      "confidence": "medium",
      "severity": "medium",
      "category": "generics",
      "framework": "java"
    },
    {
      "id": "java_type_inference_failure",
      "pattern": "cannot infer type arguments|type inference failed|ambiguous type|cannot instantiate type variable",
      "error_type": "TypeInferenceFailure",
      "description": "Compiler cannot infer generic types from context",
      "root_cause": "java_type_inference_failure",
      "suggestion": "Provide explicit type arguments: method.<Type>call() or new Class<Type>(). Simplify complex generic expressions.",
      "confidence": "high",
      "severity": "medium",
      "category": "generics",
      "framework": "java"
    },
    {
      "id": "java_diamond_operator_error",
      "pattern": "diamond operator is not supported|<> cannot be used with|incorrect number of type arguments",
      "error_type": "DiamondOperatorError",
      "description": "Incorrect usage of diamond operator for type inference",
      "root_cause": "java_diamond_operator_error",
      "suggestion": "Use diamond operator <> only with constructor calls in Java 7+. Ensure left side has type information for inference.",
      "confidence": "high",
      "severity": "low",
      "category": "generics",
      "framework": "java"
    },
    {
      "id": "java_recursive_type_bound",
      "pattern": "cyclic inheritance|recursive type parameter|type parameter .* has cyclic dependency",
      "error_type": "RecursiveTypeBound",
      "description": "Recursive or cyclic type parameter bounds",
      "root_cause": "java_recursive_type_bound",
      "suggestion": "Simplify recursive type bounds. Common pattern: T extends Comparable<T>. Avoid complex circular dependencies.",
      "confidence": "medium",
      "severity": "medium",
      "category": "generics",
      "framework": "java"
    },
    {
      "id": "java_intersection_type_error",
      "pattern": "incompatible types in intersection|cannot be accessed from .* bound",
      "error_type": "IntersectionTypeError",
      "description": "Error with intersection types in bounds (T extends A & B)",
      "root_cause": "java_intersection_type_error",
      "suggestion": "Ensure intersection type members are compatible. Order matters: class must come before interfaces in bounds.",
      "confidence": "medium",
      "severity": "medium",
      "category": "generics",
      "framework": "java"
    },
    {
      "id": "java_generic_constructor_error",
      "pattern": "cannot instantiate the type|wrong number of type arguments|constructor .* cannot be applied",
      "error_type": "GenericConstructorError",
      "description": "Error instantiating generic types or constructors",
      "root_cause": "java_generic_constructor_error",
      "suggestion": "Provide correct type arguments for constructor. Cannot instantiate type parameters directly - use factory methods or class tokens.",
      "confidence": "high",
      "severity": "high",
      "category": "generics",
      "framework": "java"
    },
    {
      "id": "java_generic_static_context",
      "pattern": "cannot make a static reference to the non-static type|type parameter .* cannot be referenced from a static context",
      "error_type": "GenericStaticContext",
      "description": "Using class type parameters in static context",
      "root_cause": "java_generic_static_context",
      "suggestion": "Static methods cannot use class type parameters. Declare separate type parameters for static generic methods.",
      "confidence": "high",
      "severity": "high",
      "category": "generics",
      "framework": "java"
    },
    {
      "id": "java_bridge_method_conflict",
      "pattern": "bridge method|synthetic method|accidentally overrides the following",
      "error_type": "BridgeMethodConflict",
      "description": "Conflict with compiler-generated bridge methods",
      "root_cause": "java_bridge_method_conflict",
      "suggestion": "Avoid method signatures that conflict with bridge methods. Be careful when overriding generic methods.",
      "confidence": "low",
      "severity": "medium",
      "category": "generics",
      "framework": "java"
    },
    {
      "id": "java_type_witness_error",
      "pattern": "explicit type argument .* does not conform to|method .* in .* cannot be applied to given types",
      "error_type": "TypeWitnessError",
      "description": "Explicit type witness doesn't match method constraints",
      "root_cause": "java_type_witness_error",
      "suggestion": "Check explicit type arguments match method type parameter bounds. Let compiler infer types when possible.",
      "confidence": "medium",
      "severity": "medium",
      "category": "generics",
      "framework": "java"
    }
  ]
}