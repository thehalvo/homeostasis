{
  "name": "Java Performance Error Patterns",
  "description": "Performance optimization patterns for Java applications",
  "version": "1.0.0",
  "rules": [
    {
      "id": "java_performance_memory_leak",
      "pattern": "OutOfMemoryError|memory leak|heap space|GC overhead limit exceeded",
      "type": "OutOfMemoryError",
      "description": "Memory leak or excessive memory usage detected",
      "root_cause": "memory_leak",
      "suggestion": "Check for unclosed resources, static collections holding references, listeners not removed, or thread local variables",
      "category": "java",
      "subcategory": "memory",
      "severity": "critical",
      "confidence": "high",
      "tags": ["performance", "memory", "leak"]
    },
    {
      "id": "java_performance_string_concatenation",
      "pattern": "String concatenation in loop|\\+ inside (for|while).*String|inefficient string building",
      "type": "PerformanceError",
      "description": "Inefficient string concatenation in loop",
      "root_cause": "inefficient_string_operation",
      "suggestion": "Use StringBuilder or StringBuffer for string concatenation in loops",
      "category": "java",
      "subcategory": "string",
      "severity": "medium",
      "confidence": "high",
      "tags": ["performance", "string", "loop"]
    },
    {
      "id": "java_performance_n_plus_1_query",
      "pattern": "N\\+1 query|multiple queries in loop|Hibernate.*LazyInitializationException|JPA.*fetch",
      "type": "PerformanceError",
      "description": "N+1 query problem in ORM usage",
      "root_cause": "database_inefficiency",
      "suggestion": "Use JOIN FETCH, @EntityGraph, or batch fetching to load related entities efficiently",
      "category": "java",
      "subcategory": "database",
      "severity": "high",
      "confidence": "high",
      "tags": ["performance", "database", "orm"]
    },
    {
      "id": "java_performance_synchronized_collection",
      "pattern": "Vector|Hashtable|StringBuffer in concurrent|synchronized collection performance",
      "type": "PerformanceError",
      "description": "Using legacy synchronized collections",
      "root_cause": "inefficient_concurrency",
      "suggestion": "Use ConcurrentHashMap, CopyOnWriteArrayList, or java.util.concurrent collections",
      "category": "java",
      "subcategory": "concurrency",
      "severity": "medium",
      "confidence": "high",
      "tags": ["performance", "concurrency", "collections"]
    },
    {
      "id": "java_performance_reflection_overhead",
      "pattern": "reflection in loop|Method\\.invoke.*performance|frequent reflection calls",
      "type": "PerformanceError",
      "description": "Excessive reflection usage causing performance overhead",
      "root_cause": "reflection_overhead",
      "suggestion": "Cache Method/Field objects, use MethodHandles, or generate bytecode at compile time",
      "category": "java",
      "subcategory": "reflection",
      "severity": "medium",
      "confidence": "medium",
      "tags": ["performance", "reflection", "overhead"]
    },
    {
      "id": "java_performance_boxing_unboxing",
      "pattern": "autoboxing in loop|Integer\\s+i\\s*=\\s*0.*loop|boxing/unboxing overhead",
      "type": "PerformanceError",
      "description": "Excessive autoboxing/unboxing in performance-critical code",
      "root_cause": "boxing_overhead",
      "suggestion": "Use primitive types in loops, avoid unnecessary wrapper classes",
      "category": "java",
      "subcategory": "primitives",
      "severity": "medium",
      "confidence": "high",
      "tags": ["performance", "boxing", "primitives"]
    },
    {
      "id": "java_performance_stream_misuse",
      "pattern": "stream\\(\\)\\.count\\(\\)|stream for side effects|parallel stream.*small collection",
      "type": "PerformanceError",
      "description": "Inefficient use of Java Streams API",
      "root_cause": "stream_inefficiency",
      "suggestion": "Use Collection.size() instead of stream().count(), avoid parallel streams for small data",
      "category": "java",
      "subcategory": "streams",
      "severity": "medium",
      "confidence": "medium",
      "tags": ["performance", "streams", "functional"]
    },
    {
      "id": "java_performance_thread_pool_sizing",
      "pattern": "thread pool.*exhausted|rejected execution|queue.*full|thread starvation",
      "type": "PerformanceError",
      "description": "Thread pool sizing or configuration issue",
      "root_cause": "thread_pool_misconfiguration",
      "suggestion": "Adjust thread pool size based on workload, use appropriate queue type and rejection policy",
      "category": "java",
      "subcategory": "threading",
      "severity": "high",
      "confidence": "medium",
      "tags": ["performance", "threading", "pool"]
    },
    {
      "id": "java_performance_regex_compilation",
      "pattern": "Pattern\\.compile.*loop|Pattern\\.matches.*repeated|regex compilation overhead",
      "type": "PerformanceError",
      "description": "Repeated regex pattern compilation",
      "root_cause": "regex_compilation_overhead",
      "suggestion": "Compile Pattern once and reuse, store as static final field",
      "category": "java",
      "subcategory": "regex",
      "severity": "medium",
      "confidence": "high",
      "tags": ["performance", "regex", "compilation"]
    },
    {
      "id": "java_performance_collection_sizing",
      "pattern": "ArrayList.*frequent resize|HashMap.*rehash|initial capacity too small",
      "type": "PerformanceError",
      "description": "Collection resizing overhead due to poor initial sizing",
      "root_cause": "collection_resize_overhead",
      "suggestion": "Set appropriate initial capacity for ArrayList, HashMap based on expected size",
      "category": "java",
      "subcategory": "collections",
      "severity": "low",
      "confidence": "medium",
      "tags": ["performance", "collections", "sizing"]
    },
    {
      "id": "java_performance_gc_pressure",
      "pattern": "GC overhead|frequent garbage collection|allocation rate too high|gc pause",
      "type": "PerformanceError",
      "description": "High garbage collection pressure affecting performance",
      "root_cause": "gc_pressure",
      "suggestion": "Reduce object allocation, use object pools, tune GC parameters, consider G1GC or ZGC",
      "category": "java",
      "subcategory": "gc",
      "severity": "high",
      "confidence": "high",
      "tags": ["performance", "gc", "memory"]
    },
    {
      "id": "java_performance_jdbc_batch",
      "pattern": "executeUpdate in loop|single row inserts|JDBC.*not batched",
      "type": "PerformanceError",
      "description": "Not using JDBC batch operations for bulk updates",
      "root_cause": "jdbc_inefficiency",
      "suggestion": "Use PreparedStatement.addBatch() and executeBatch() for bulk operations",
      "category": "java",
      "subcategory": "database",
      "severity": "high",
      "confidence": "high",
      "tags": ["performance", "jdbc", "batch"]
    },
    {
      "id": "java_performance_synchronization_overhead",
      "pattern": "synchronized method.*high contention|lock contention|synchronized block.*performance",
      "type": "PerformanceError",
      "description": "Excessive synchronization causing contention",
      "root_cause": "synchronization_overhead",
      "suggestion": "Use lock-free algorithms, ReadWriteLock, or reduce synchronization scope",
      "category": "java",
      "subcategory": "concurrency",
      "severity": "high",
      "confidence": "medium",
      "tags": ["performance", "synchronization", "contention"]
    },
    {
      "id": "java_performance_logging_overhead",
      "pattern": "logger\\.debug.*production|string concatenation.*log|logging performance impact",
      "type": "PerformanceError",
      "description": "Excessive logging or inefficient log statement construction",
      "root_cause": "logging_overhead",
      "suggestion": "Use parameterized logging, check log level before building message, use async logging",
      "category": "java",
      "subcategory": "logging",
      "severity": "medium",
      "confidence": "medium",
      "tags": ["performance", "logging", "overhead"]
    },
    {
      "id": "java_performance_finalize_usage",
      "pattern": "finalize\\(\\)|finalizer|PhantomReference.*performance",
      "type": "PerformanceError",
      "description": "Using finalizers which impact garbage collection performance",
      "root_cause": "finalizer_overhead",
      "suggestion": "Use try-with-resources, AutoCloseable, or Cleaner API instead of finalizers",
      "category": "java",
      "subcategory": "gc",
      "severity": "medium",
      "confidence": "high",
      "tags": ["performance", "finalizer", "gc"]
    }
  ]
}