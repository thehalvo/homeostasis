{
  "description": "Java Android error detection rules for activity lifecycle, fragments, and platform-specific issues",
  "version": "1.0.0",
  "rules": [
    {
      "id": "java_android_activity_not_found",
      "pattern": "android\\.content\\.ActivityNotFoundException.*",
      "error_type": "ActivityNotFoundException",
      "description": "No activity found to handle the given intent",
      "root_cause": "java_android_activity_not_found",
      "suggestion": "Verify intent action/data and ensure target activity is declared in AndroidManifest.xml with proper intent filters. Check if the target app is installed.",
      "confidence": "high",
      "severity": "high",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_activity_lifecycle_state",
      "pattern": ".*IllegalStateException.*activity.*destroyed.*|.*activity.*not.*created.*|.*activity.*finishing.*",
      "error_type": "IllegalStateException",
      "description": "Activity operation attempted in wrong lifecycle state",
      "root_cause": "java_android_lifecycle_violation",
      "suggestion": "Check activity lifecycle state with isDestroyed(), isFinishing() before operations. Use lifecycle-aware components or ViewModels for persistent data.",
      "confidence": "high",
      "severity": "high",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_view_not_found",
      "pattern": ".*findViewById.*returned null.*|.*view.*with id.*not found.*",
      "error_type": "NullPointerException",
      "description": "View with specified ID not found in layout",
      "root_cause": "java_android_view_not_found",
      "suggestion": "Verify view ID exists in current layout file. Use findViewById after setContentView() or inflate. Consider using View Binding or Data Binding.",
      "confidence": "high",
      "severity": "medium",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_context_null",
      "pattern": ".*context.*null.*|.*getApplicationContext.*returned null.*",
      "error_type": "NullPointerException",
      "description": "Context is null when accessed",
      "root_cause": "java_android_context_null",
      "suggestion": "Store application context for long-lived objects. Use WeakReference for activity context. Check context availability before use.",
      "confidence": "medium",
      "severity": "medium",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_main_thread_network",
      "pattern": ".*NetworkOnMainThreadException.*|.*main thread.*network.*",
      "error_type": "NetworkOnMainThreadException",
      "description": "Network operation attempted on main UI thread",
      "root_cause": "java_android_main_thread_violation",
      "suggestion": "Perform network operations in background thread using AsyncTask, ExecutorService, or modern alternatives like OkHttp with callbacks.",
      "confidence": "high",
      "severity": "high",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_wrong_thread_ui",
      "pattern": ".*CalledFromWrongThreadException.*|.*UI.*wrong thread.*|.*ViewRootImpl.*CalledFromWrongThreadException.*",
      "error_type": "CalledFromWrongThreadException",
      "description": "UI operation attempted from background thread",
      "root_cause": "java_android_ui_thread_violation",
      "suggestion": "Update UI on main thread using runOnUiThread(), Handler.post(), or Activity.runOnUiThread() from background threads.",
      "confidence": "high",
      "severity": "high",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_permission_denied",
      "pattern": ".*Permission.*denied.*|.*SecurityException.*permission.*",
      "error_type": "SecurityException",
      "description": "Required permission not granted",
      "root_cause": "java_android_permission_denied",
      "suggestion": "Request runtime permissions using ActivityCompat.requestPermissions() for API 23+. Declare permissions in AndroidManifest.xml and handle permission results.",
      "confidence": "high",
      "severity": "high",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_window_bad_token",
      "pattern": ".*WindowManager.*BadTokenException.*|.*window.*token.*invalid.*",
      "error_type": "BadTokenException",
      "description": "Attempted to show dialog/popup with invalid window token",
      "root_cause": "java_android_window_bad_token",
      "suggestion": "Ensure activity is active and not finishing before showing dialogs. Check isFinishing() and isDestroyed() before dialog display.",
      "confidence": "high",
      "severity": "medium",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_fragment_transaction_illegal_state",
      "pattern": ".*IllegalStateException.*commit.*after.*onSaveInstanceState.*|.*fragment.*transaction.*committed.*",
      "error_type": "IllegalStateException",
      "description": "Fragment transaction committed after onSaveInstanceState",
      "root_cause": "java_android_fragment_transaction_timing",
      "suggestion": "Use commitAllowingStateLoss() if state loss is acceptable, or ensure transactions are committed before onSaveInstanceState(). Consider using ChildFragmentManager for nested fragments.",
      "confidence": "high",
      "severity": "medium",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_fragment_not_attached",
      "pattern": ".*Fragment.*not attached.*|.*getActivity.*returned null.*|.*requireActivity.*IllegalStateException.*",
      "error_type": "IllegalStateException",
      "description": "Fragment method called when not attached to activity",
      "root_cause": "java_android_fragment_not_attached",
      "suggestion": "Check isAdded() before accessing activity/context. Use getActivity() with null checks or store application context for long-lived operations.",
      "confidence": "high",
      "severity": "medium",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_recyclerview_no_adapter",
      "pattern": ".*RecyclerView.*no adapter.*|.*adapter.*not set.*recyclerview.*",
      "error_type": "IllegalStateException",
      "description": "RecyclerView used without setting adapter",
      "root_cause": "java_android_recyclerview_no_adapter",
      "suggestion": "Set adapter on RecyclerView before use: recyclerView.setAdapter(yourAdapter). Also set LayoutManager if not defined in XML.",
      "confidence": "high",
      "severity": "medium",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_intent_extra_null",
      "pattern": ".*intent.*extra.*null.*|.*getStringExtra.*returned null.*",
      "error_type": "NullPointerException",
      "description": "Intent extra is null when accessed",
      "root_cause": "java_android_intent_extra_null",
      "suggestion": "Check for extra existence with hasExtra() or provide default values. Use intent.getStringExtra(key, defaultValue) pattern.",
      "confidence": "medium",
      "severity": "medium",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_bundle_key_not_found",
      "pattern": ".*bundle.*key.*not found.*|.*Bundle.*missing.*",
      "error_type": "NullPointerException",
      "description": "Bundle key not found or Bundle is null",
      "root_cause": "java_android_bundle_key_missing",
      "suggestion": "Check Bundle nullability and key existence before access. Use containsKey() method or provide default values for missing keys.",
      "confidence": "medium",
      "severity": "medium",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_service_not_found",
      "pattern": ".*service.*not found.*|.*ServiceConnectionException.*",
      "error_type": "ServiceConnectionException",
      "description": "Service not found or unable to connect",
      "root_cause": "java_android_service_not_found",
      "suggestion": "Verify service is declared in AndroidManifest.xml and running. Check service lifecycle and binding. Use explicit intents for local services.",
      "confidence": "medium",
      "severity": "medium",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_broadcast_receiver_leak",
      "pattern": ".*BroadcastReceiver.*leak.*|.*receiver.*not unregistered.*",
      "error_type": "MemoryLeak",
      "description": "BroadcastReceiver not unregistered causing memory leak",
      "root_cause": "java_android_receiver_leak",
      "suggestion": "Unregister BroadcastReceiver in onPause/onDestroy using unregisterReceiver(). Use LocalBroadcastManager for app-internal broadcasts.",
      "confidence": "medium",
      "severity": "medium",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_cursor_not_closed",
      "pattern": ".*cursor.*not closed.*|.*Cursor.*leak.*",
      "error_type": "ResourceLeak",
      "description": "Database cursor not properly closed",
      "root_cause": "java_android_cursor_leak",
      "suggestion": "Always close cursors in finally block or use try-with-resources. Consider migrating to Room database for modern data persistence.",
      "confidence": "medium",
      "severity": "medium",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_memory_leak_activity",
      "pattern": ".*activity.*leaked.*|.*memory leak.*activity.*",
      "error_type": "MemoryLeak",
      "description": "Activity context held after destruction causing memory leak",
      "root_cause": "java_android_memory_leak",
      "suggestion": "Use weak references for activity context in long-lived objects. Use application context when possible. Avoid static references to activities.",
      "confidence": "medium",
      "severity": "high",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_api_level_unsupported",
      "pattern": ".*NoSuchMethodError.*API.*level.*|.*method.*not available.*API.*",
      "error_type": "NoSuchMethodError",
      "description": "Method called that's not available in current API level",
      "root_cause": "java_android_api_compatibility",
      "suggestion": "Check API level with Build.VERSION.SDK_INT before calling newer APIs. Use @TargetApi annotation or AndroidX compatibility libraries.",
      "confidence": "high",
      "severity": "high",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_resources_not_found",
      "pattern": ".*Resources\\$NotFoundException.*|.*resource.*not found.*",
      "error_type": "Resources$NotFoundException",
      "description": "Resource not found at runtime",
      "root_cause": "java_android_resource_not_found",
      "suggestion": "Verify resource exists in appropriate density/configuration folders. Check resource name and type (drawable, string, etc.). Clean and rebuild project.",
      "confidence": "high",
      "severity": "medium",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_asynctask_deprecated",
      "pattern": ".*AsyncTask.*deprecated.*|.*AsyncTask.*doInBackground.*",
      "error_type": "DeprecationWarning",
      "description": "AsyncTask is deprecated in API 30+",
      "root_cause": "java_android_asynctask_deprecated",
      "suggestion": "Replace AsyncTask with ExecutorService, HandlerThread, or modern alternatives like Kotlin coroutines. Use java.util.concurrent package for background tasks.",
      "confidence": "medium",
      "severity": "low",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_kotlin_interop_null_safety",
      "pattern": ".*KotlinNullPointerException.*|.*null.*kotlin.*java.*interop.*",
      "error_type": "KotlinNullPointerException",
      "description": "Null safety violation when calling Kotlin from Java or vice versa",
      "root_cause": "java_kotlin_null_safety_violation",
      "suggestion": "Use @Nullable/@NonNull annotations in Java. In Kotlin, use platform types carefully and add null checks when calling Java code.",
      "confidence": "high",
      "severity": "high",
      "category": "android",
      "framework": "kotlin-interop"
    },
    {
      "id": "java_kotlin_interop_unit_return",
      "pattern": ".*Unit.*return.*java.*kotlin.*|.*void.*kotlin.*function.*",
      "error_type": "TypeMismatchException",
      "description": "Incorrect handling of Kotlin Unit type in Java",
      "root_cause": "java_kotlin_unit_type_mismatch",
      "suggestion": "Kotlin Unit functions appear as void in Java. Don't try to return or use the Unit value in Java code.",
      "confidence": "medium",
      "severity": "medium",
      "category": "android",
      "framework": "kotlin-interop"
    },
    {
      "id": "java_kotlin_interop_companion_object",
      "pattern": ".*Companion.*not.*accessible.*|.*companion.*object.*java.*",
      "error_type": "IllegalAccessException",
      "description": "Incorrect access to Kotlin companion object from Java",
      "root_cause": "java_kotlin_companion_access",
      "suggestion": "Access Kotlin companion object members using ClassName.Companion.methodName() in Java, or use @JvmStatic annotation in Kotlin.",
      "confidence": "medium",
      "severity": "medium",
      "category": "android",
      "framework": "kotlin-interop"
    },
    {
      "id": "java_kotlin_interop_data_class",
      "pattern": ".*data.*class.*java.*access.*|.*kotlin.*data.*class.*constructor.*",
      "error_type": "NoSuchMethodException",
      "description": "Incorrect instantiation of Kotlin data class from Java",
      "root_cause": "java_kotlin_data_class_access",
      "suggestion": "Kotlin data classes can be instantiated from Java like regular classes. Use the generated constructor with all parameters.",
      "confidence": "medium",
      "severity": "medium",
      "category": "android",
      "framework": "kotlin-interop"
    },
    {
      "id": "java_kotlin_interop_coroutines",
      "pattern": ".*suspend.*function.*java.*|.*coroutine.*java.*call.*",
      "error_type": "UnsupportedOperationException",
      "description": "Attempting to call Kotlin suspend function from Java",
      "root_cause": "java_kotlin_suspend_function_call",
      "suggestion": "Kotlin suspend functions cannot be called directly from Java. Wrap them in regular functions or use runBlocking for testing.",
      "confidence": "high",
      "severity": "medium",
      "category": "android",
      "framework": "kotlin-interop"
    },
    {
      "id": "java_android_service_binding_failed",
      "pattern": ".*service.*binding.*failed.*|.*bindService.*returned.*false.*",
      "error_type": "ServiceBindingException",
      "description": "Failed to bind to Android service",
      "root_cause": "java_android_service_binding_failed",
      "suggestion": "Check service declaration in manifest, ensure service is running, and verify intent is explicit. Handle binding failures gracefully.",
      "confidence": "medium",
      "severity": "medium",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_service_leak",
      "pattern": ".*service.*leak.*|.*service.*not.*stopped.*",
      "error_type": "ServiceLeak",
      "description": "Service not properly stopped causing resource leak",
      "root_cause": "java_android_service_leak",
      "suggestion": "Always stop services using stopService() or stopSelf(). Unbind from services in onDestroy(). Use bound services for temporary connections.",
      "confidence": "medium",
      "severity": "medium",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_background_execution_limit",
      "pattern": ".*IllegalStateException.*background.*execution.*|.*background.*service.*limitation.*",
      "error_type": "IllegalStateException",
      "description": "Background execution limits violated (API 26+)",
      "root_cause": "java_android_background_limit_violation",
      "suggestion": "Use foreground services for long-running tasks, JobScheduler for deferred work, or WorkManager for reliable background processing.",
      "confidence": "high",
      "severity": "high",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_notification_channel_missing",
      "pattern": ".*notification.*channel.*not.*found.*|.*NotificationChannel.*required.*",
      "error_type": "SecurityException",
      "description": "Notification channel required for API 26+",
      "root_cause": "java_android_notification_channel_missing",
      "suggestion": "Create notification channel before posting notifications on API 26+. Use NotificationChannel and NotificationManager.createNotificationChannel().",
      "confidence": "high",
      "severity": "medium",
      "category": "android",
      "framework": "android"
    },
    {
      "id": "java_android_work_manager_constraint",
      "pattern": ".*WorkManager.*constraint.*not.*met.*|.*work.*request.*constraints.*",
      "error_type": "WorkManagerException",
      "description": "WorkManager constraints not satisfied",
      "root_cause": "java_android_work_constraint_violation",
      "suggestion": "Review work constraints (network, battery, storage) and adjust them based on actual requirements. Consider using expedited work for time-sensitive tasks.",
      "confidence": "medium",
      "severity": "medium",
      "category": "android",
      "framework": "android"
    }
  ]
}