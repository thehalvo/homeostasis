{
  "name": "Ruby Metaprogramming Error Rules",
  "description": "Rules for detecting and fixing common Ruby metaprogramming errors",
  "version": "0.1.0",
  "rules": [
    {
      "id": "ruby_method_missing_error",
      "pattern": "NoMethodError:.*undefined method `([^']+)'.*\\(method_missing\\)",
      "type": "NoMethodError",
      "description": "method_missing handler failed or threw an error",
      "root_cause": "ruby_method_missing",
      "suggestion": "Check your method_missing implementation. Ensure it correctly handles or delegates the method call.",
      "confidence": "medium",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_const_missing_error",
      "pattern": "NameError:.*\\(const_missing\\)",
      "type": "NameError",
      "description": "const_missing handler failed or threw an error",
      "root_cause": "ruby_const_missing",
      "suggestion": "Check your const_missing implementation. Ensure it correctly loads or resolves the constant.",
      "confidence": "medium",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_respond_to_missing_error",
      "pattern": "(?:NoMethodError|TypeError):.*respond_to_missing\\?",
      "type": "NoMethodError",
      "description": "respond_to_missing? implementation error",
      "root_cause": "ruby_respond_to_missing",
      "suggestion": "Ensure respond_to_missing? returns a boolean and handles all methods that method_missing supports.",
      "confidence": "medium",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_define_method_error",
      "pattern": "(?:TypeError|ArgumentError):.*define_method",
      "type": "TypeError",
      "description": "Error in dynamic method definition",
      "root_cause": "ruby_define_method",
      "suggestion": "Check arguments to define_method. The first argument should be a symbol or string, and the second should be a Proc, Method, or block.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_singleton_method_error",
      "pattern": "TypeError: can't define singleton method.*",
      "type": "TypeError",
      "description": "Failed to define singleton method",
      "root_cause": "ruby_singleton_method",
      "suggestion": "Ensure the object can have singleton methods. Some types (e.g., Fixnum, Symbol) don't support singleton methods.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_include_object_error",
      "pattern": "TypeError: wrong argument type (?:Class|Module) \\(expected Module\\)",
      "type": "TypeError",
      "description": "Attempted to include a non-module",
      "root_cause": "ruby_include_type_error",
      "suggestion": "Use include only with modules. For classes, consider inheritance (class Child < Parent). For objects, consider delegation.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_extend_error",
      "pattern": "TypeError: wrong argument type .* \\(expected Module\\) for `extend'",
      "type": "TypeError",
      "description": "Attempted to extend with a non-module",
      "root_cause": "ruby_extend_type_error",
      "suggestion": "Use extend only with modules. Check that you're not trying to extend with a class or other non-module.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_prepend_error",
      "pattern": "TypeError: wrong argument type .* \\(expected Module\\) for `prepend'",
      "type": "TypeError",
      "description": "Attempted to prepend with a non-module",
      "root_cause": "ruby_prepend_type_error",
      "suggestion": "Use prepend only with modules. Check that you're not trying to prepend with a class or other non-module.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_class_eval_error",
      "pattern": "(?:SyntaxError|TypeError):.*\\bclas[s]?_eval\\b",
      "type": "SyntaxError",
      "description": "Error in class_eval string or block",
      "root_cause": "ruby_class_eval_error",
      "suggestion": "Check the syntax of the string or block passed to class_eval. Prefer using a block over a string for better error reporting.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_instance_eval_error",
      "pattern": "(?:SyntaxError|TypeError):.*\\binstance_eval\\b",
      "type": "SyntaxError",
      "description": "Error in instance_eval string or block",
      "root_cause": "ruby_instance_eval_error",
      "suggestion": "Check the syntax of the string or block passed to instance_eval. Prefer using a block over a string for better error reporting.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_inherited_hook_error",
      "pattern": "(?:NoMethodError|ArgumentError):.*\\binherited\\b",
      "type": "NoMethodError",
      "description": "Error in inherited callback",
      "root_cause": "ruby_inherited_hook",
      "suggestion": "Check your inherited method implementation. It should accept a subclass parameter and handle it correctly.",
      "confidence": "medium",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_module_inclusion_error",
      "pattern": "(?:NoMethodError|ArgumentError):.*\\bincluded\\b",
      "type": "NoMethodError",
      "description": "Error in included callback",
      "root_cause": "ruby_module_inclusion",
      "suggestion": "Check your included method implementation. It should accept a class parameter and handle it correctly.",
      "confidence": "medium",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_module_extension_error",
      "pattern": "(?:NoMethodError|ArgumentError):.*\\bextended\\b",
      "type": "NoMethodError",
      "description": "Error in extended callback",
      "root_cause": "ruby_module_extension",
      "suggestion": "Check your extended method implementation. It should accept an object parameter and handle it correctly.",
      "confidence": "medium",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_class_variable_error",
      "pattern": "RuntimeError: class variable (@@[^ ]+) (not initialized|access from toplevel|of [^ ]+ is already initialized)",
      "type": "RuntimeError",
      "description": "Class variable access or initialization error",
      "root_cause": "ruby_class_variable_error",
      "suggestion": "Ensure class variables are initialized before use. Be careful with class variables in inheritance hierarchies; consider class instance variables instead.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_dynamic_constant_error",
      "pattern": "SyntaxError: dynamic constant assignment",
      "type": "SyntaxError",
      "description": "Attempted to assign to a constant in a dynamic context",
      "root_cause": "ruby_dynamic_constant",
      "suggestion": "Use const_set for dynamic constant assignment instead of direct assignment. Remember that constants can only be defined in class/module definition context.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_attr_accessor_error",
      "pattern": "(?:NameError|NoMethodError):.*on attr_(reader|writer|accessor)",
      "type": "NameError",
      "description": "Error in attr_accessor, attr_reader, or attr_writer usage",
      "root_cause": "ruby_attr_accessor",
      "suggestion": "Ensure attr methods are called with symbol arguments. Remember they can only be called in class/module definition context.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_send_error",
      "pattern": "NoMethodError:.*`send'",
      "type": "NoMethodError",
      "description": "Error when using send to invoke a method dynamically",
      "root_cause": "ruby_send_error",
      "suggestion": "Check that the method name passed to send exists. Use respond_to? to verify before calling.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_public_send_error",
      "pattern": "NoMethodError:.*`public_send'",
      "type": "NoMethodError",
      "description": "Error when using public_send to invoke a method dynamically",
      "root_cause": "ruby_public_send_error",
      "suggestion": "Check that the method name passed to public_send exists and is public. Use respond_to? to verify before calling.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_method_added_error",
      "pattern": "(?:SystemStackError|ArgumentError):.*method_added",
      "type": "SystemStackError",
      "description": "Infinite recursion in method_added hook",
      "root_cause": "ruby_method_added_recursion",
      "suggestion": "Avoid defining methods within method_added that trigger the hook again. Use a guard variable to prevent recursion.",
      "confidence": "high",
      "severity": "high",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_alias_method_error",
      "pattern": "NameError: undefined method `([^']+)' for (class|module)",
      "type": "NameError",
      "description": "Attempting to alias a non-existent method",
      "root_cause": "ruby_alias_undefined",
      "suggestion": "Ensure the method exists before aliasing. Check method definition order in the class.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_remove_method_error",
      "pattern": "NameError: method `([^']+)' not defined in",
      "type": "NameError",
      "description": "Attempting to remove undefined method",
      "root_cause": "ruby_remove_undefined",
      "suggestion": "Check if method exists before removing. Use method_defined? or respond_to? to verify.",
      "confidence": "high",
      "severity": "low",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_undef_method_error",
      "pattern": "NameError: undefined method `([^']+)' for (class|module)",
      "type": "NameError",
      "description": "Attempting to undefine non-existent method",
      "root_cause": "ruby_undef_undefined",
      "suggestion": "Verify method exists before undefining. Note that undef is more aggressive than remove_method.",
      "confidence": "high",
      "severity": "low",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_refinement_error",
      "pattern": "RuntimeError: can't activate refinement",
      "type": "RuntimeError",
      "description": "Refinement activation error",
      "root_cause": "ruby_refinement",
      "suggestion": "Refinements must be activated with 'using' at the top level of a file or module. Check scope.",
      "confidence": "medium",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_singleton_class_error",
      "pattern": "TypeError: can't create instance of singleton class",
      "type": "TypeError",
      "description": "Attempted to instantiate singleton class",
      "root_cause": "ruby_singleton_instantiation",
      "suggestion": "Singleton classes cannot be instantiated directly. Access via object.singleton_class.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_method_visibility_error",
      "pattern": "NoMethodError: (private|protected) method `([^']+)' called",
      "type": "NoMethodError",
      "description": "Calling private or protected method incorrectly",
      "root_cause": "ruby_method_visibility",
      "suggestion": "Use send to call private methods, or change visibility with public/private/protected declarations.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_define_singleton_method_error",
      "pattern": "TypeError:.*define_singleton_method",
      "type": "TypeError",
      "description": "Error defining singleton method",
      "root_cause": "ruby_define_singleton",
      "suggestion": "Check object supports singleton methods. Immediate values (true, false, nil, symbols, numbers) don't.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_instance_variable_error",
      "pattern": "`([^']+)' is not allowed as an instance variable name",
      "type": "NameError",
      "description": "Invalid instance variable name",
      "root_cause": "ruby_invalid_ivar",
      "suggestion": "Instance variables must start with @. Use valid Ruby identifier after @.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_autoload_error",
      "pattern": "LoadError:.*autoload",
      "type": "LoadError",
      "description": "Autoload failed to find file",
      "root_cause": "ruby_autoload",
      "suggestion": "Check autoload path is correct. File must be in load path and match the constant name.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_method_source_error",
      "pattern": "MethodSource::SourceNotFoundError",
      "type": "SourceNotFoundError",
      "description": "Cannot find method source",
      "root_cause": "ruby_method_source",
      "suggestion": "Method may be defined in C, dynamically, or in irb/pry. Not all methods have accessible source.",
      "confidence": "medium",
      "severity": "low",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_eval_binding_error",
      "pattern": "NameError:.*eval.*binding",
      "type": "NameError",
      "description": "Variable not accessible in eval binding",
      "root_cause": "ruby_eval_binding",
      "suggestion": "Pass correct binding to eval. Variables must exist in the binding context.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_super_error",
      "pattern": "(?:NoMethodError|ArgumentError): super: no superclass method",
      "type": "NoMethodError",
      "description": "No superclass method to call",
      "root_cause": "ruby_super_missing",
      "suggestion": "Ensure parent class/module defines the method before calling super. Check inheritance chain.",
      "confidence": "high",
      "severity": "medium",
      "category": "metaprogramming"
    },
    {
      "id": "ruby_delegation_error",
      "pattern": "NoMethodError:.*Delegator",
      "type": "NoMethodError",
      "description": "Delegation target missing method",
      "root_cause": "ruby_delegation",
      "suggestion": "Ensure delegated object responds to the method. Check delegation setup and target object.",
      "confidence": "medium",
      "severity": "medium",
      "category": "metaprogramming"
    }
  ]
}