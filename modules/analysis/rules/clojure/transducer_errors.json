{
  "name": "Clojure Transducer Errors",
  "version": "1.0.0",
  "description": "Clojure transducer composition and usage error detection rules",
  "rules": [
    {
      "id": "clojure_transducer_composition_order",
      "category": "transducers",
      "type": "composition",
      "pattern": "transducer composition.*wrong order|comp.*transducers.*unexpected result|filter after map.*inefficient",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Transducers compose left-to-right with comp. Order matters for correctness and performance",
      "root_cause": "clojure_transducer_comp_order",
      "tags": [
        "clojure",
        "transducer",
        "composition",
        "order"
      ],
      "description": "Clojure Transducer Composition Order"
    },
    {
      "id": "clojure_stateful_transducer_error",
      "category": "transducers",
      "type": "stateful",
      "pattern": "stateful transducer.*shared state|volatile!.*transducer.*concurrent|partition-by.*state corruption",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Stateful transducers must not share state. Create new instances for each use",
      "root_cause": "clojure_transducer_shared_state",
      "tags": [
        "clojure",
        "transducer",
        "stateful",
        "concurrent"
      ],
      "description": "Clojure Stateful Transducer"
    },
    {
      "id": "clojure_reduced_not_respected",
      "category": "transducers",
      "type": "early_termination",
      "pattern": "reduced value.*not respected|early termination.*ignored|reduced.*unwrapped incorrectly",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Respect reduced values for early termination. Use unreduced carefully",
      "root_cause": "clojure_reduced_ignored",
      "tags": [
        "clojure",
        "transducer",
        "reduced",
        "termination"
      ],
      "description": "Clojure Reduced Not Respected"
    },
    {
      "id": "clojure_transducer_context_mismatch",
      "category": "transducers",
      "type": "context",
      "pattern": "transducer.*cannot be used with.*lazy seq|into.*transducer.*wrong context|sequence.*stateful transducer",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Some transducers work differently in different contexts (into vs sequence vs chan)",
      "root_cause": "clojure_transducer_context",
      "tags": [
        "clojure",
        "transducer",
        "context",
        "usage"
      ],
      "description": "Clojure Transducer Context Mismatch"
    },
    {
      "id": "clojure_transducer_stack_overflow",
      "category": "transducers",
      "type": "performance",
      "pattern": "StackOverflowError.*transducer|too many transducers composed|deep transducer nesting",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "high",
      "suggestion": "Avoid excessive transducer composition. Consider breaking into steps",
      "root_cause": "clojure_transducer_stack_depth",
      "tags": [
        "clojure",
        "transducer",
        "stackoverflow",
        "composition"
      ],
      "description": "Clojure Transducer Stack Overflow"
    },
    {
      "id": "clojure_completing_function_error",
      "category": "transducers",
      "type": "completing",
      "pattern": "completing function.*arity|completion step.*failed|transducer.*completion.*wrong type",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Completing functions need both 2-arity (step) and 1-arity (completion) implementations",
      "root_cause": "clojure_completing_arity",
      "tags": [
        "clojure",
        "transducer",
        "completing",
        "arity"
      ],
      "description": "Clojure Completing Function"
    },
    {
      "id": "clojure_transducer_type_mismatch",
      "category": "transducers",
      "type": "type_error",
      "pattern": "transducer.*expected.*function|not a transducer|cannot transduce.*type",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Transducers must be functions that transform reducing functions",
      "root_cause": "clojure_not_transducer",
      "tags": [
        "clojure",
        "transducer",
        "type",
        "function"
      ],
      "description": "Clojure Transducer Type Mismatch"
    },
    {
      "id": "clojure_parallel_fold_error",
      "category": "transducers",
      "type": "parallel",
      "pattern": "fold.*transducer.*failed|parallel fold.*stateful transducer|r/fold.*incorrect result",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Not all transducers work with parallel fold. Ensure combine function is provided",
      "root_cause": "clojure_fold_transducer",
      "tags": [
        "clojure",
        "transducer",
        "fold",
        "parallel"
      ],
      "description": "Clojure Parallel Fold"
    },
    {
      "id": "clojure_cat_transducer_error",
      "category": "transducers",
      "type": "cat",
      "pattern": "cat transducer.*not flattening|mapcat.*transducer.*issue|cat expects.*collection",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "cat transducer flattens one level. Input must be collections",
      "root_cause": "clojure_cat_transducer",
      "tags": [
        "clojure",
        "transducer",
        "cat",
        "flatten"
      ],
      "description": "Clojure Cat Transducer"
    },
    {
      "id": "clojure_transducer_init_value",
      "category": "transducers",
      "type": "initialization",
      "pattern": "transducer.*no init value|reduce.*transducer.*empty collection|init arity missing",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Provide initial value for transduce or ensure reducing function has 0-arity",
      "root_cause": "clojure_transducer_init",
      "tags": [
        "clojure",
        "transducer",
        "init",
        "reduce"
      ],
      "description": "Clojure Transducer Init Value"
    },
    {
      "id": "clojure_transducer_resource_cleanup",
      "category": "transducers",
      "type": "resources",
      "pattern": "transducer.*resource.*not cleaned|completion step.*close.*failed|with-open.*transducer",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "high",
      "suggestion": "Use completion arity to clean up resources in stateful transducers",
      "root_cause": "clojure_transducer_cleanup",
      "tags": [
        "clojure",
        "transducer",
        "resource",
        "cleanup"
      ],
      "description": "Clojure Transducer Resource Cleanup"
    },
    {
      "id": "clojure_dedupe_transducer_state",
      "category": "transducers",
      "type": "dedupe",
      "pattern": "dedupe.*transducer.*wrong results|distinct.*stateful.*issue|duplicate removal failed",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "dedupe and distinct are stateful transducers. Don't reuse instances",
      "root_cause": "clojure_dedupe_state",
      "tags": [
        "clojure",
        "transducer",
        "dedupe",
        "stateful"
      ],
      "description": "Clojure Dedupe Transducer State"
    },
    {
      "id": "clojure_partition_transducer_remainder",
      "category": "transducers",
      "type": "partition",
      "pattern": "partition-all.*vs.*partition|remainder elements.*lost|partition.*incomplete.*ignored",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "partition drops incomplete groups. Use partition-all to keep remainder",
      "root_cause": "clojure_partition_remainder",
      "tags": [
        "clojure",
        "transducer",
        "partition",
        "remainder"
      ],
      "description": "Clojure Partition Transducer Remainder"
    },
    {
      "id": "clojure_halt_when_condition",
      "category": "transducers",
      "type": "halt",
      "pattern": "halt-when.*predicate.*never true|halt-when.*missed condition|early termination.*not triggered",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "halt-when stops on predicate match. Ensure predicate logic is correct",
      "root_cause": "clojure_halt_when",
      "tags": [
        "clojure",
        "transducer",
        "halt",
        "predicate"
      ],
      "description": "Clojure Halt When Condition"
    },
    {
      "id": "clojure_eduction_realization",
      "category": "transducers",
      "type": "eduction",
      "pattern": "eduction.*realized multiple times|eduction.*performance|repeated computation.*eduction",
      "confidence": "low",
      "reliability": "low",
      "severity": "low",
      "suggestion": "Eductions are recomputed on each use. Cache results if needed",
      "root_cause": "clojure_eduction_recompute",
      "tags": [
        "clojure",
        "transducer",
        "eduction",
        "performance"
      ],
      "description": "Clojure Eduction Realization"
    }
  ]
}