{
  "version": "1.0.0",
  "description": "Clojure lazy sequence realization and performance error detection rules",
  "rules": [
    {
      "id": "clojure_infinite_sequence_realization",
      "category": "lazy_sequences",
      "type": "infinite_realization",
      "pattern": "OutOfMemoryError.*infinite.*seq|Attempting to realize infinite sequence|StackOverflowError.*iterate|range.*Integer/MAX_VALUE",
      "confidence": "high",
      "reliability": "high",
      "severity": "critical",
      "suggestion": "Use take, take-while, or other limiting functions before realizing infinite sequences",
      "root_cause": "clojure_infinite_seq_realized",
      "tags": ["clojure", "lazy", "infinite", "memory"]
    },
    {
      "id": "clojure_chunked_sequence_performance",
      "category": "lazy_sequences",
      "type": "chunking",
      "pattern": "Chunked seq.*performance|unexpected realization.*chunk|32 elements realized at once",
      "confidence": "low",
      "reliability": "low",
      "severity": "low",
      "suggestion": "Be aware of chunked sequences (32 elements). Use (seq (eduction ...)) to avoid chunking",
      "root_cause": "clojure_chunked_seq_performance",
      "tags": ["clojure", "lazy", "chunked", "performance"]
    },
    {
      "id": "clojure_side_effects_in_lazy_seq",
      "category": "lazy_sequences",
      "type": "side_effects",
      "pattern": "side effect.*lazy.*not executed|println.*map.*not showing|IO in lazy sequence",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Avoid side effects in lazy sequences. Use doseq for side effects or doall to force realization",
      "root_cause": "clojure_lazy_side_effects",
      "tags": ["clojure", "lazy", "side_effect", "io"]
    },
    {
      "id": "clojure_head_retention_memory_leak",
      "category": "lazy_sequences",
      "type": "head_retention",
      "pattern": "head retention.*memory leak|holding onto head of sequence|OutOfMemoryError.*lazy-seq",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "high",
      "suggestion": "Don't hold references to heads of large lazy sequences. Process and discard",
      "root_cause": "clojure_head_retention",
      "tags": ["clojure", "lazy", "memory_leak", "head"]
    },
    {
      "id": "clojure_doall_dorun_misuse",
      "category": "lazy_sequences",
      "type": "realization",
      "pattern": "doall.*returned.*not used|dorun used.*need results|doseq.*on infinite sequence",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Use doall to realize and keep results, dorun for side effects only, doseq for iteration",
      "root_cause": "clojure_lazy_realization_misuse",
      "tags": ["clojure", "lazy", "doall", "dorun"]
    },
    {
      "id": "clojure_lazy_seq_in_atom_ref",
      "category": "lazy_sequences",
      "type": "state_management",
      "pattern": "lazy sequence in atom|ref contains unrealized seq|STM.*lazy-seq",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Realize lazy sequences before storing in atoms/refs to avoid realization during transactions",
      "root_cause": "clojure_lazy_in_state",
      "tags": ["clojure", "lazy", "atom", "ref"]
    },
    {
      "id": "clojure_lazy_seq_delay_interaction",
      "category": "lazy_sequences",
      "type": "delay_interaction",
      "pattern": "delay.*lazy-seq.*forced multiple times|deref.*lazy sequence.*performance",
      "confidence": "low",
      "reliability": "low",
      "severity": "low",
      "suggestion": "Combine delay with lazy-seq carefully. Consider memoization for expensive computations",
      "root_cause": "clojure_lazy_delay_combo",
      "tags": ["clojure", "lazy", "delay", "deref"]
    },
    {
      "id": "clojure_recursive_lazy_seq_stackoverflow",
      "category": "lazy_sequences",
      "type": "recursion",
      "pattern": "StackOverflowError.*lazy-seq|recursive lazy sequence|deep recursion in lazy-seq",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Use recur for tail recursion or trampoline for mutual recursion in lazy sequences",
      "root_cause": "clojure_lazy_recursion_overflow",
      "tags": ["clojure", "lazy", "recursion", "stackoverflow"]
    },
    {
      "id": "clojure_lazy_filter_nothing_found",
      "category": "lazy_sequences",
      "type": "filtering",
      "pattern": "filter.*realized entire.*nothing found|scanning infinite seq.*filter",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Use (first (filter ...)) with take-while or limited sequences to avoid full realization",
      "root_cause": "clojure_lazy_filter_exhaustive",
      "tags": ["clojure", "lazy", "filter", "realization"]
    },
    {
      "id": "clojure_concat_stackoverflow",
      "category": "lazy_sequences",
      "type": "concat",
      "pattern": "StackOverflowError.*concat|too many nested concat|apply concat.*deep nesting",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Avoid deeply nested concat. Use into or reduce with conj for better performance",
      "root_cause": "clojure_concat_overflow",
      "tags": ["clojure", "lazy", "concat", "nesting"]
    },
    {
      "id": "clojure_lazy_io_resource_leak",
      "category": "lazy_sequences",
      "type": "io_resource",
      "pattern": "file handle.*not closed.*lazy|resource leak.*lazy-seq|with-open.*lazy sequence escaped",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Don't return lazy sequences from with-open. Realize within the resource scope",
      "root_cause": "clojure_lazy_io_leak",
      "tags": ["clojure", "lazy", "io", "resource"]
    },
    {
      "id": "clojure_lazy_parallel_overhead",
      "category": "lazy_sequences",
      "type": "parallelization",
      "pattern": "pmap.*slower than map|parallel overhead.*lazy|reducers.*on lazy seq",
      "confidence": "low",
      "reliability": "low",
      "severity": "low",
      "suggestion": "pmap has overhead. Use for CPU-intensive operations. Consider reducers for parallelism",
      "root_cause": "clojure_lazy_parallel_overhead",
      "tags": ["clojure", "lazy", "parallel", "pmap"]
    },
    {
      "id": "clojure_lazy_seq_type_hint_loss",
      "category": "lazy_sequences",
      "type": "type_hints",
      "pattern": "reflection warning.*lazy-seq|type hint lost.*through lazy sequence",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "low",
      "suggestion": "Type hints may be lost through lazy sequences. Re-hint after realization if needed",
      "root_cause": "clojure_lazy_type_hint",
      "tags": ["clojure", "lazy", "reflection", "type_hint"]
    },
    {
      "id": "clojure_lazy_nesting_complexity",
      "category": "lazy_sequences",
      "type": "nesting",
      "pattern": "deeply nested lazy sequences|lazy-seq.*lazy-seq.*lazy-seq|complex lazy composition",
      "confidence": "low",
      "reliability": "low",
      "severity": "medium",
      "suggestion": "Simplify deeply nested lazy operations. Consider transducers for complex transformations",
      "root_cause": "clojure_lazy_nesting",
      "tags": ["clojure", "lazy", "nesting", "complexity"]
    },
    {
      "id": "clojure_unrealized_in_equality",
      "category": "lazy_sequences",
      "type": "equality",
      "pattern": "comparing lazy sequences|equality check.*realized.*seq|= operator.*lazy-seq",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Equality comparison realizes lazy sequences. Consider if full realization is intended",
      "root_cause": "clojure_lazy_equality_realizes",
      "tags": ["clojure", "lazy", "equality", "comparison"]
    }
  ]
}