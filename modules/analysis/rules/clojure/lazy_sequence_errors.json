{
  "name": "Clojure Lazy Sequence Errors",
  "version": "1.0.0",
  "description": "Clojure lazy sequence realization and performance error detection rules",
  "rules": [
    {
      "id": "clojure_infinite_sequence_realization",
      "category": "lazy_sequences",
      "type": "infinite_realization",
      "pattern": "OutOfMemoryError.*infinite.*seq|Attempting to realize infinite sequence|StackOverflowError.*iterate|range.*Integer/MAX_VALUE",
      "confidence": "high",
      "reliability": "high",
      "severity": "critical",
      "suggestion": "Use take, take-while, or other limiting functions before realizing infinite sequences",
      "root_cause": "clojure_infinite_seq_realized",
      "tags": [
        "clojure",
        "lazy",
        "infinite",
        "memory"
      ],
      "description": "Clojure Infinite Sequence Realization"
    },
    {
      "id": "clojure_chunked_sequence_performance",
      "category": "lazy_sequences",
      "type": "chunking",
      "pattern": "Chunked seq.*performance|unexpected realization.*chunk|32 elements realized at once",
      "confidence": "low",
      "reliability": "low",
      "severity": "low",
      "suggestion": "Be aware of chunked sequences (32 elements). Use (seq (eduction ...)) to avoid chunking",
      "root_cause": "clojure_chunked_seq_performance",
      "tags": [
        "clojure",
        "lazy",
        "chunked",
        "performance"
      ],
      "description": "Clojure Chunked Sequence Performance"
    },
    {
      "id": "clojure_side_effects_in_lazy_seq",
      "category": "lazy_sequences",
      "type": "side_effects",
      "pattern": "side effect.*lazy.*not executed|println.*map.*not showing|IO in lazy sequence",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Avoid side effects in lazy sequences. Use doseq for side effects or doall to force realization",
      "root_cause": "clojure_lazy_side_effects",
      "tags": [
        "clojure",
        "lazy",
        "side_effect",
        "io"
      ],
      "description": "Clojure Side Effects In Lazy Seq"
    },
    {
      "id": "clojure_head_retention_memory_leak",
      "category": "lazy_sequences",
      "type": "head_retention",
      "pattern": "head retention.*memory leak|holding onto head of sequence|OutOfMemoryError.*lazy-seq",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "high",
      "suggestion": "Don't hold references to heads of large lazy sequences. Process and discard",
      "root_cause": "clojure_head_retention",
      "tags": [
        "clojure",
        "lazy",
        "memory_leak",
        "head"
      ],
      "description": "Clojure Head Retention Memory Leak"
    },
    {
      "id": "clojure_doall_dorun_misuse",
      "category": "lazy_sequences",
      "type": "realization",
      "pattern": "doall.*returned.*not used|dorun used.*need results|doseq.*on infinite sequence",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Use doall to realize and keep results, dorun for side effects only, doseq for iteration",
      "root_cause": "clojure_lazy_realization_misuse",
      "tags": [
        "clojure",
        "lazy",
        "doall",
        "dorun"
      ],
      "description": "Clojure Doall Dorun Misuse"
    },
    {
      "id": "clojure_lazy_seq_in_atom_ref",
      "category": "lazy_sequences",
      "type": "state_management",
      "pattern": "lazy sequence in atom|ref contains unrealized seq|STM.*lazy-seq",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Realize lazy sequences before storing in atoms/refs to avoid realization during transactions",
      "root_cause": "clojure_lazy_in_state",
      "tags": [
        "clojure",
        "lazy",
        "atom",
        "ref"
      ],
      "description": "Clojure Lazy Seq In Atom Ref"
    },
    {
      "id": "clojure_lazy_seq_delay_interaction",
      "category": "lazy_sequences",
      "type": "delay_interaction",
      "pattern": "delay.*lazy-seq.*forced multiple times|deref.*lazy sequence.*performance",
      "confidence": "low",
      "reliability": "low",
      "severity": "low",
      "suggestion": "Combine delay with lazy-seq carefully. Consider memoization for expensive computations",
      "root_cause": "clojure_lazy_delay_combo",
      "tags": [
        "clojure",
        "lazy",
        "delay",
        "deref"
      ],
      "description": "Clojure Lazy Seq Delay Interaction"
    },
    {
      "id": "clojure_recursive_lazy_seq_stackoverflow",
      "category": "lazy_sequences",
      "type": "recursion",
      "pattern": "StackOverflowError.*lazy-seq|recursive lazy sequence|deep recursion in lazy-seq",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Use recur for tail recursion or trampoline for mutual recursion in lazy sequences",
      "root_cause": "clojure_lazy_recursion_overflow",
      "tags": [
        "clojure",
        "lazy",
        "recursion",
        "stackoverflow"
      ],
      "description": "Clojure Recursive Lazy Seq Stackoverflow"
    },
    {
      "id": "clojure_lazy_filter_nothing_found",
      "category": "lazy_sequences",
      "type": "filtering",
      "pattern": "filter.*realized entire.*nothing found|scanning infinite seq.*filter",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Use (first (filter ...)) with take-while or limited sequences to avoid full realization",
      "root_cause": "clojure_lazy_filter_exhaustive",
      "tags": [
        "clojure",
        "lazy",
        "filter",
        "realization"
      ],
      "description": "Clojure Lazy Filter Nothing Found"
    },
    {
      "id": "clojure_concat_stackoverflow",
      "category": "lazy_sequences",
      "type": "concat",
      "pattern": "StackOverflowError.*concat|too many nested concat|apply concat.*deep nesting",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Avoid deeply nested concat. Use into or reduce with conj for better performance",
      "root_cause": "clojure_concat_overflow",
      "tags": [
        "clojure",
        "lazy",
        "concat",
        "nesting"
      ],
      "description": "Clojure Concat Stackoverflow"
    },
    {
      "id": "clojure_lazy_io_resource_leak",
      "category": "lazy_sequences",
      "type": "io_resource",
      "pattern": "file handle.*not closed.*lazy|resource leak.*lazy-seq|with-open.*lazy sequence escaped",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Don't return lazy sequences from with-open. Realize within the resource scope",
      "root_cause": "clojure_lazy_io_leak",
      "tags": [
        "clojure",
        "lazy",
        "io",
        "resource"
      ],
      "description": "Clojure Lazy Io Resource Leak"
    },
    {
      "id": "clojure_lazy_parallel_overhead",
      "category": "lazy_sequences",
      "type": "parallelization",
      "pattern": "pmap.*slower than map|parallel overhead.*lazy|reducers.*on lazy seq",
      "confidence": "low",
      "reliability": "low",
      "severity": "low",
      "suggestion": "pmap has overhead. Use for CPU-intensive operations. Consider reducers for parallelism",
      "root_cause": "clojure_lazy_parallel_overhead",
      "tags": [
        "clojure",
        "lazy",
        "parallel",
        "pmap"
      ],
      "description": "Clojure Lazy Parallel Overhead"
    },
    {
      "id": "clojure_lazy_seq_type_hint_loss",
      "category": "lazy_sequences",
      "type": "type_hints",
      "pattern": "reflection warning.*lazy-seq|type hint lost.*through lazy sequence",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "low",
      "suggestion": "Type hints may be lost through lazy sequences. Re-hint after realization if needed",
      "root_cause": "clojure_lazy_type_hint",
      "tags": [
        "clojure",
        "lazy",
        "reflection",
        "type_hint"
      ],
      "description": "Clojure Lazy Seq Type Hint Loss"
    },
    {
      "id": "clojure_lazy_nesting_complexity",
      "category": "lazy_sequences",
      "type": "nesting",
      "pattern": "deeply nested lazy sequences|lazy-seq.*lazy-seq.*lazy-seq|complex lazy composition",
      "confidence": "low",
      "reliability": "low",
      "severity": "medium",
      "suggestion": "Simplify deeply nested lazy operations. Consider transducers for complex transformations",
      "root_cause": "clojure_lazy_nesting",
      "tags": [
        "clojure",
        "lazy",
        "nesting",
        "complexity"
      ],
      "description": "Clojure Lazy Nesting Complexity"
    },
    {
      "id": "clojure_unrealized_in_equality",
      "category": "lazy_sequences",
      "type": "equality",
      "pattern": "comparing lazy sequences|equality check.*realized.*seq|= operator.*lazy-seq",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Equality comparison realizes lazy sequences. Consider if full realization is intended",
      "root_cause": "clojure_lazy_equality_realizes",
      "tags": [
        "clojure",
        "lazy",
        "equality",
        "comparison"
      ],
      "description": "Clojure Unrealized In Equality"
    }
  ]
}