{
  "rules": [
    {
      "id": "hibernate_entity_not_found",
      "pattern": "org\\.hibernate\\.ObjectNotFoundException(?:.*?No row with the given identifier exists.*?|.*?entity: ([^,]+),.*?identifier: ([^\\)]+)\\)?)",
      "type": "ObjectNotFoundException",
      "description": "Entity not found with the specified identifier",
      "root_cause": "hibernate_entity_not_found",
      "suggestion": "Handle the case where the entity doesn't exist. Use Optional.ofNullable() with findById() or add explicit null checks. Consider logging the missing entity ID and provide meaningful error messages to the client.",
      "confidence": "high",
      "severity": "medium",
      "category": "hibernate",
      "framework": "hibernate"
    },
    {
      "id": "hibernate_query_syntax",
      "pattern": "org\\.hibernate\\.hql\\.internal\\.ast\\.QuerySyntaxException(?:.*?expecting ([^,]+), found '([^']+)'.*?|.*?expecting '([^']+)', found '([^']+)'.*?|.*?invalid path: '([^']+)'.*?|.*?(antlr\\.NoViableAltException|unexpected token).*?)",
      "type": "QuerySyntaxException",
      "description": "Syntax error in HQL/JPQL query",
      "root_cause": "hibernate_invalid_query",
      "suggestion": "Fix the syntax error in your HQL/JPQL query. Check entity names, property names, and query structure. Use named parameters or parameter binding to avoid SQL injection and syntax errors.",
      "confidence": "high",
      "severity": "medium",
      "category": "hibernate",
      "framework": "hibernate"
    },
    {
      "id": "hibernate_non_unique_result",
      "pattern": "org\\.hibernate\\.NonUniqueResultException(?:.*?query did not return a unique result.*?)?",
      "type": "NonUniqueResultException",
      "description": "Query expected to return a single result returned multiple results",
      "root_cause": "hibernate_multiple_results",
      "suggestion": "Use getSingleResult() only when you are certain that exactly one result will be returned. Consider using getResultList().stream().findFirst() or add additional conditions to your query to ensure uniqueness.",
      "confidence": "high",
      "severity": "medium",
      "category": "hibernate",
      "framework": "hibernate"
    },
    {
      "id": "hibernate_many_to_one_not_found",
      "pattern": "org\\.hibernate\\.MappingException(?:.*?Unknown entity: ([^\\s]+).*?|.*?could not resolve property: ([^ ]+) of: ([^\\)]+)\\)?)",
      "type": "MappingException",
      "description": "Entity or property not found in Hibernate mapping",
      "root_cause": "hibernate_mapping_error",
      "suggestion": "Verify entity class names and property names in mappings. Ensure all entities are properly annotated with @Entity and registered with EntityManagerFactory. Check for typos in property names referenced in queries.",
      "confidence": "high",
      "severity": "high",
      "category": "hibernate",
      "framework": "hibernate"
    },
    {
      "id": "hibernate_property_not_found",
      "pattern": "org\\.hibernate\\.PropertyNotFoundException(?:.*?Could not find a setter for property ([^ ]+) in class ([^\\s]+).*?|.*?Could not find a getter for property ([^ ]+) in class ([^\\s]+).*?)",
      "type": "PropertyNotFoundException",
      "description": "Property not found on entity class",
      "root_cause": "hibernate_unknown_property",
      "suggestion": "Verify property names in queries and mappings. Ensure the property exists in the entity class with proper getter/setter methods. Check for typos in property names.",
      "confidence": "high",
      "severity": "high",
      "category": "hibernate",
      "framework": "hibernate"
    },
    {
      "id": "hibernate_constraint_violation",
      "pattern": "org\\.hibernate\\.exception\\.ConstraintViolationException(?:.*?constraint \\[([^\\]]+)\\].*?|.*?integrity constraint violation.*?table: \"([^\"]+)\".*?|.*?cannot be null.*?)",
      "type": "ConstraintViolationException",
      "description": "Database constraint violation during entity operation",
      "root_cause": "hibernate_constraint_violation",
      "suggestion": "Ensure entity data satisfies database constraints before persisting. Add validation logic with Bean Validation (JSR 380) annotations like @NotNull, @Size, etc. Handle constraint violations gracefully with proper error messages.",
      "confidence": "high",
      "severity": "high",
      "category": "hibernate",
      "framework": "hibernate"
    },
    {
      "id": "hibernate_pessimistic_lock",
      "pattern": "org\\.hibernate\\.PessimisticLockException(?:.*?could not obtain pessimistic lock.*?|.*?timed out.*?|.*?dead lock.*?)",
      "type": "PessimisticLockException",
      "description": "Failed to obtain a pessimistic lock on entity",
      "root_cause": "hibernate_lock_failure",
      "suggestion": "Revisit your locking strategy. Consider using optimistic locking with @Version instead. If pessimistic locking is necessary, implement proper timeout handling and retry logic. Be mindful of the transaction isolation level.",
      "confidence": "high",
      "severity": "high",
      "category": "hibernate",
      "framework": "hibernate"
    },
    {
      "id": "hibernate_lazy_init",
      "pattern": "org\\.hibernate\\.LazyInitializationException(?:.*?could not initialize proxy.*?|.*?no Session.*?)",
      "type": "LazyInitializationException",
      "description": "Attempted to access a lazily-initialized collection or proxy outside of a session",
      "root_cause": "hibernate_lazy_initialization",
      "suggestion": "Ensure lazily loaded associations are accessed within an open Hibernate session. Consider using EAGER fetching for associations that are always needed, or fetch them explicitly with JOIN FETCH in your queries. Spring's OpenSessionInViewFilter can help but has its drawbacks.",
      "confidence": "high",
      "severity": "high",
      "category": "hibernate",
      "framework": "hibernate"
    },
    {
      "id": "hibernate_stale_state",
      "pattern": "org\\.hibernate\\.StaleStateException(?:.*?Batch update returned unexpected row count.*?|.*?optimistic lock.*?|.*?Row was updated or deleted by another transaction.*?)",
      "type": "StaleStateException",
      "description": "Concurrent modification detected during entity update",
      "root_cause": "hibernate_stale_state",
      "suggestion": "Implement optimistic locking with @Version fields to detect concurrent modifications. Provide conflict resolution logic or retry mechanisms. Consider using a pessimistic lock for critical operations where conflicts cannot be tolerated.",
      "confidence": "high",
      "severity": "high",
      "category": "hibernate",
      "framework": "hibernate"
    },
    {
      "id": "hibernate_data_exception",
      "pattern": "org\\.hibernate\\.exception\\.DataException(?:.*?data too long.*?|.*?value too large.*?|.*?truncation.*?|.*?incorrect.*?|.*?invalid.*?)",
      "type": "DataException",
      "description": "Data-related exception during database operation",
      "root_cause": "hibernate_invalid_data",
      "suggestion": "Validate data before persisting it to the database. Use Bean Validation constraints with appropriate limits (@Size, @Max, etc.). Ensure entity field types match database column types and sizes.",
      "confidence": "high",
      "severity": "high",
      "category": "hibernate",
      "framework": "hibernate"
    },
    {
      "id": "jpa_no_transaction",
      "pattern": "javax\\.persistence\\.TransactionRequiredException(?:.*?no transaction is in progress.*?|.*?Transaction is required to perform this operation.*?)",
      "type": "TransactionRequiredException",
      "description": "Operation requires an active transaction, but none exists",
      "root_cause": "jpa_missing_transaction",
      "suggestion": "Ensure methods that modify entities are annotated with @Transactional. Check transaction boundaries and propagation settings. For Spring, verify that @EnableTransactionManagement is present and transaction manager is configured.",
      "confidence": "high",
      "severity": "high",
      "category": "jpa",
      "framework": "hibernate"
    },
    {
      "id": "jpa_entity_exists",
      "pattern": "javax\\.persistence\\.EntityExistsException(?:.*?entity with the same identifier value is already associated with the session.*?|.*?duplicate entry.*?|.*?already exists.*?)",
      "type": "EntityExistsException",
      "description": "Attempted to persist an entity that already exists",
      "root_cause": "jpa_duplicate_entity",
      "suggestion": "Check if the entity exists before persisting it. Use merge() instead of persist() when appropriate. For new entities, ensure they have unique IDs or let the database generate them.",
      "confidence": "high",
      "severity": "medium",
      "category": "jpa",
      "framework": "hibernate"
    },
    {
      "id": "jpa_entity_not_found",
      "pattern": "javax\\.persistence\\.EntityNotFoundException(?:.*?Unable to find ([^\\s]+) with id ([^\\s]+).*?)",
      "type": "EntityNotFoundException",
      "description": "Referenced entity does not exist in the database",
      "root_cause": "jpa_missing_entity",
      "suggestion": "Check if entities exist before referencing them. Use Optional<Entity> with findById() and handle empty results gracefully. Consider adding foreign key constraints in the database.",
      "confidence": "high",
      "severity": "medium",
      "category": "jpa",
      "framework": "hibernate"
    },
    {
      "id": "jpa_optimistic_lock",
      "pattern": "javax\\.persistence\\.OptimisticLockException(?:.*?optimistic locking failed.*?|.*?Row was updated or deleted by another transaction.*?)",
      "type": "OptimisticLockException",
      "description": "Optimistic locking failed due to concurrent modification",
      "root_cause": "jpa_concurrent_modification",
      "suggestion": "Implement proper conflict resolution strategy for concurrent modifications. Refresh the entity and attempt the operation again, or present the conflict to the user. Consider using pessimistic locking for highly-contended resources.",
      "confidence": "high",
      "severity": "high",
      "category": "jpa",
      "framework": "hibernate"
    },
    {
      "id": "jpa_query_timeout",
      "pattern": "javax\\.persistence\\.QueryTimeoutException(?:.*?Query execution was interrupted.*?|.*?timed out.*?)",
      "type": "QueryTimeoutException",
      "description": "Query execution timed out",
      "root_cause": "jpa_query_timeout",
      "suggestion": "Optimize the query for better performance. Add appropriate indexes on queried columns. Consider paginating results or using projections to fetch only needed data. Increase the query timeout if appropriate.",
      "confidence": "high",
      "severity": "high",
      "category": "jpa",
      "framework": "hibernate"
    }
  ]
}