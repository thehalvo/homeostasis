{
  "description": "C# delegates, events, and functional programming error detection rules",
  "version": "1.0.0",
  "rules": [
    {
      "id": "csharp_null_delegate_invocation",
      "pattern": "NullReferenceException.*delegate|invoke.*null.*Action|Func.*null.*invoke",
      "type": "NullReferenceException",
      "description": "Invoking null delegate",
      "root_cause": "csharp_null_delegate",
      "suggestion": "Use null-conditional operator: delegate?.Invoke() or eventHandler?.Invoke(). Always check delegates before invocation.",
      "confidence": "high",
      "severity": "high",
      "category": "delegates",
      "framework": "csharp"
    },
    {
      "id": "csharp_event_null_invocation",
      "pattern": "event.*null.*fired|EventHandler.*NullReferenceException|null.*event.*raised",
      "type": "NullReferenceException",
      "description": "Raising null event",
      "root_cause": "csharp_null_event",
      "suggestion": "Copy event to local variable and use ?. operator: var handler = MyEvent; handler?.Invoke(this, args);",
      "confidence": "high",
      "severity": "high",
      "category": "delegates",
      "framework": "csharp"
    },
    {
      "id": "csharp_delegate_combine_type_mismatch",
      "pattern": "InvalidCastException.*Delegate\\.Combine|incompatible delegate types|MulticastDelegate.*type mismatch",
      "type": "InvalidCastException",
      "description": "Combining incompatible delegate types",
      "root_cause": "csharp_delegate_combine_error",
      "suggestion": "Ensure delegates have same signature when combining with + operator. Cast to specific delegate type if needed.",
      "confidence": "high",
      "severity": "medium",
      "category": "delegates",
      "framework": "csharp"
    },
    {
      "id": "csharp_event_memory_leak",
      "pattern": "memory leak.*event|event handler.*not removed|strong reference.*event subscriber",
      "type": "MemoryLeak",
      "description": "Event handler causing memory leak",
      "root_cause": "csharp_event_memory_leak",
      "suggestion": "Unsubscribe from events when no longer needed. Use weak event patterns or WeakEventManager for long-lived publishers.",
      "confidence": "medium",
      "severity": "high",
      "category": "delegates",
      "framework": "csharp"
    },
    {
      "id": "csharp_anonymous_method_capture",
      "pattern": "captured variable.*modified|closure.*unexpected value|lambda.*capture.*changed",
      "type": "ClosureCaptureIssue",
      "description": "Unexpected variable capture in anonymous method",
      "root_cause": "csharp_closure_capture",
      "suggestion": "Be aware of variable capture in loops. Create local copy of loop variable for lambdas/anonymous methods.",
      "confidence": "medium",
      "severity": "medium",
      "category": "delegates",
      "framework": "csharp"
    },
    {
      "id": "csharp_action_func_confusion",
      "pattern": "cannot convert.*Action.*Func|Func.*Action.*incompatible|void.*return.*expected",
      "type": "DelegateTypeMismatch",
      "description": "Confusion between Action and Func delegates",
      "root_cause": "csharp_action_func_mismatch",
      "suggestion": "Use Action for void-returning delegates, Func<T> for delegates with return values. Action<T> takes parameters but returns void.",
      "confidence": "high",
      "severity": "medium",
      "category": "delegates",
      "framework": "csharp"
    },
    {
      "id": "csharp_delegate_beginvoke_obsolete",
      "pattern": "BeginInvoke.*obsolete|EndInvoke.*not supported|asynchronous delegate.*deprecated",
      "type": "ObsoleteApiUsage",
      "description": "Using obsolete asynchronous delegate invocation",
      "root_cause": "csharp_delegate_async_obsolete",
      "suggestion": "Use Task.Run() or async/await instead of BeginInvoke/EndInvoke. Asynchronous delegates are obsolete in .NET Core.",
      "confidence": "high",
      "severity": "medium",
      "category": "delegates",
      "framework": "csharp"
    },
    {
      "id": "csharp_multicast_delegate_return",
      "pattern": "multicast delegate.*return value|multiple delegates.*which return|last delegate.*return",
      "type": "MulticastDelegateReturn",
      "description": "Return value behavior in multicast delegates",
      "root_cause": "csharp_multicast_return",
      "suggestion": "Only last delegate's return value is used in multicast. Use GetInvocationList() to handle all returns individually.",
      "confidence": "medium",
      "severity": "low",
      "category": "delegates",
      "framework": "csharp"
    },
    {
      "id": "csharp_event_race_condition",
      "pattern": "race condition.*event|thread.*event.*null check|concurrent.*event subscription",
      "type": "RaceCondition",
      "description": "Race condition in event handling",
      "root_cause": "csharp_event_race",
      "suggestion": "Copy event to local variable before null check and invocation. Consider thread-safe event patterns.",
      "confidence": "medium",
      "severity": "high",
      "category": "delegates",
      "framework": "csharp"
    },
    {
      "id": "csharp_delegate_variance_error",
      "pattern": "covariance.*contravariance.*delegate|in.*out.*delegate.*parameter|variance.*not valid",
      "type": "VarianceError",
      "description": "Delegate variance violation",
      "root_cause": "csharp_delegate_variance",
      "suggestion": "Understand delegate variance: covariant return types (out), contravariant parameters (in). Available in C# 9+.",
      "confidence": "medium",
      "severity": "medium",
      "category": "delegates",
      "framework": "csharp"
    },
    {
      "id": "csharp_expression_delegate_conversion",
      "pattern": "cannot convert.*expression.*delegate|Expression<.*>.*delegate|lambda.*expression tree",
      "type": "ExpressionConversionError",
      "description": "Expression tree to delegate conversion error",
      "root_cause": "csharp_expression_conversion",
      "suggestion": "Use Compile() to convert Expression<TDelegate> to delegate. Not all lambdas can be expression trees.",
      "confidence": "medium",
      "severity": "medium",
      "category": "delegates",
      "framework": "csharp"
    },
    {
      "id": "csharp_weak_event_pattern",
      "pattern": "WeakEventManager.*error|weak reference.*event.*lost|event.*garbage collected",
      "type": "WeakEventError",
      "description": "Weak event pattern implementation issue",
      "root_cause": "csharp_weak_event_error",
      "suggestion": "Ensure weak event handlers are kept alive as needed. Consider IWeakEventListener or modern weak event patterns.",
      "confidence": "low",
      "severity": "medium",
      "category": "delegates",
      "framework": "csharp"
    },
    {
      "id": "csharp_func_task_await",
      "pattern": "Func<Task>.*not awaited|async delegate.*Task.*forgotten|fire-and-forget.*unintended",
      "type": "AsyncDelegateError",
      "description": "Async delegate not properly awaited",
      "root_cause": "csharp_async_delegate",
      "suggestion": "Await async delegates or use Func<Task> with proper task handling. Consider async event handlers carefully.",
      "confidence": "medium",
      "severity": "high",
      "category": "delegates",
      "framework": "csharp"
    },
    {
      "id": "csharp_delegate_method_group",
      "pattern": "method group.*ambiguous|overload.*method group.*conversion|cannot convert method group",
      "type": "MethodGroupConversion",
      "description": "Method group conversion ambiguity",
      "root_cause": "csharp_method_group_ambiguous",
      "suggestion": "Cast method group to specific delegate type or use lambda to resolve ambiguity: (Action)MethodName or () => MethodName()",
      "confidence": "medium",
      "severity": "medium",
      "category": "delegates",
      "framework": "csharp"
    },
    {
      "id": "csharp_custom_event_accessor",
      "pattern": "event.*add.*remove.*incorrect|custom event accessor.*error|event.*backing field",
      "type": "CustomEventError",
      "description": "Error in custom event accessor implementation",
      "root_cause": "csharp_custom_event_error",
      "suggestion": "Ensure thread-safety in custom add/remove. Use lock or concurrent collections. Handle null delegates properly.",
      "confidence": "low",
      "severity": "medium",
      "category": "delegates",
      "framework": "csharp"
    }
  ]
}