{
  "name": "Elixir Beam Errors",
  "rules": [
    {
      "id": "beam_badarg_error",
      "pattern": "\\*\\* \\(ArgumentError\\) argument error.?\\n.*?:erlang\\.([^:]+)\\(",
      "type": "ArgumentError",
      "description": "Bad argument to an Erlang function",
      "root_cause": "beam_badarg_error",
      "suggestion": "Check that you're passing the correct types of arguments to Erlang functions. Use pattern matching or type checking to validate inputs.",
      "confidence": "high",
      "severity": "medium",
      "category": "beam",
      "framework": "beam"
    },
    {
      "id": "beam_badarith_error",
      "pattern": "\\*\\* \\(ArithmeticError\\) bad argument in arithmetic expression.?\\n.*?:erlang\\.([^:]+)\\(",
      "type": "ArithmeticError",
      "description": "Error in arithmetic operation",
      "root_cause": "beam_badarith_error",
      "suggestion": "Verify all operands are numbers. Check for division by zero, and validate that all operands in math expressions are numeric types.",
      "confidence": "high",
      "severity": "medium",
      "category": "beam",
      "framework": "beam"
    },
    {
      "id": "beam_badmatch_error",
      "pattern": "\\*\\* \\(MatchError\\) no match of right hand side value: (.*)",
      "type": "MatchError",
      "description": "Pattern match failed",
      "root_cause": "beam_badmatch_error",
      "suggestion": "Check your pattern matching expression. Make sure the pattern on the left side can match the value on the right side. Consider using case statements to handle multiple possible patterns.",
      "confidence": "high",
      "severity": "medium",
      "category": "beam",
      "framework": "beam"
    },
    {
      "id": "beam_case_clause_error",
      "pattern": "\\*\\* \\(CaseClauseError\\) no case clause matching: (.*)",
      "type": "CaseClauseError",
      "description": "No matching case clause",
      "root_cause": "beam_case_clause_error",
      "suggestion": "Add a catch-all clause to your case statement (like `_ -> handle_default`). Ensure all possible values are covered by your patterns.",
      "confidence": "high",
      "severity": "medium",
      "category": "beam",
      "framework": "beam"
    },
    {
      "id": "beam_function_clause_error",
      "pattern": "\\*\\* \\(FunctionClauseError\\) no function clause matching in (.*)",
      "type": "FunctionClauseError",
      "description": "No matching function clause for the given arguments",
      "root_cause": "beam_function_clause_error",
      "suggestion": "Add a function clause that can handle the arguments being passed. Consider adding a catch-all clause with appropriate error handling.",
      "confidence": "high",
      "severity": "medium",
      "category": "beam",
      "framework": "beam"
    },
    {
      "id": "beam_badrecord_error",
      "pattern": "\\*\\* \\(ArgumentError\\) Bad record: (.*)",
      "type": "ArgumentError",
      "description": "Invalid record format",
      "root_cause": "beam_badrecord_error",
      "suggestion": "Verify the record type and structure. In Erlang, ensure record definitions are imported. In Elixir, check struct definitions and keys.",
      "confidence": "high",
      "severity": "medium",
      "category": "beam",
      "framework": "beam"
    },
    {
      "id": "beam_badkey_error",
      "pattern": "\\*\\* \\(KeyError\\) key (.*) not found in: (.*)",
      "type": "KeyError",
      "description": "Attempted to access a non-existent key",
      "root_cause": "beam_badkey_error",
      "suggestion": "Use Map.get/3 with a default value, or check if the key exists before accessing it with Map.has_key?/2.",
      "confidence": "high",
      "severity": "medium",
      "category": "beam",
      "framework": "beam"
    },
    {
      "id": "beam_undef_error",
      "pattern": "\\*\\* \\(UndefinedFunctionError\\) function ([^:]+):([^/]+)/\\d+ is undefined",
      "type": "UndefinedFunctionError",
      "description": "Called an undefined function",
      "root_cause": "beam_undef_error",
      "suggestion": "Check the function name and module. Ensure the module is properly imported/required and the function exists with the right arity.",
      "confidence": "high",
      "severity": "high",
      "category": "beam",
      "framework": "beam"
    },
    {
      "id": "beam_noproc_error",
      "pattern": "\\*\\* \\(exit\\) {[^}]*?noproc[^}]*}",
      "type": "ProcessError",
      "description": "Process does not exist",
      "root_cause": "beam_noproc_error",
      "suggestion": "Check that the process or registered name exists before sending messages to it. Use Process.whereis/1 or :erlang.whereis/1 to check if a registered process exists.",
      "confidence": "high",
      "severity": "medium",
      "category": "beam",
      "framework": "beam"
    },
    {
      "id": "beam_badmap_error",
      "pattern": "\\*\\* \\(BadMapError\\) (.*)",
      "type": "BadMapError",
      "description": "Invalid map operation",
      "root_cause": "beam_badmap_error",
      "suggestion": "Ensure the value is a map before performing map operations. Use is_map/1 to check if a value is a map, or use pattern matching with %{} to verify.",
      "confidence": "high",
      "severity": "medium",
      "category": "beam",
      "framework": "beam"
    },
    {
      "id": "beam_system_limit_error",
      "pattern": "\\*\\* \\(SystemLimitError\\) (.*)",
      "type": "SystemLimitError",
      "description": "BEAM VM system limit reached",
      "root_cause": "beam_system_limit_error",
      "suggestion": "Check for resource exhaustion. Common limits include process count, atom table size, or ETS table limit. Consider increasing VM limits or optimizing your application to use fewer resources.",
      "confidence": "high",
      "severity": "critical",
      "category": "beam",
      "framework": "beam"
    },
    {
      "id": "beam_try_clause_error",
      "pattern": "\\*\\* \\(TryClauseError\\) no try clause matching: (.*)",
      "type": "TryClauseError",
      "description": "No matching catch clause in try expression",
      "root_cause": "beam_try_clause_error",
      "suggestion": "Add broader exception handling to your try/catch blocks. Consider adding a catch-all clause like `catch error, _ -> handle_error` to handle unexpected errors.",
      "confidence": "high",
      "severity": "medium",
      "category": "beam",
      "framework": "beam"
    },
    {
      "id": "beam_atom_table_limit",
      "pattern": "\\*\\* \\(SystemLimitError\\) (.*?)atom table is full(.*)",
      "type": "SystemLimitError",
      "description": "BEAM VM atom table is full",
      "root_cause": "beam_atom_table_limit",
      "suggestion": "Avoid dynamic atom creation, especially from user input. Use String.to_existing_atom/1 which raises if the atom doesn't exist, or Map with string keys instead of atoms for dynamic keys.",
      "confidence": "high",
      "severity": "critical",
      "category": "beam",
      "framework": "beam"
    },
    {
      "id": "beam_distributed_node_error",
      "pattern": "\\*\\* \\(RuntimeError\\) (.*?)node (.*?) (.*)",
      "type": "RuntimeError",
      "description": "Error with distributed Erlang node communication",
      "root_cause": "beam_distributed_node_error",
      "suggestion": "Check node connectivity, name resolution, and cookie settings. Ensure nodes are properly connected and can communicate with each other.",
      "confidence": "high",
      "severity": "high",
      "category": "beam",
      "framework": "beam"
    },
    {
      "id": "beam_process_limit_error",
      "pattern": "\\*\\* \\(SystemLimitError\\) (.*?)process limit reached(.*)",
      "type": "SystemLimitError",
      "description": "Maximum number of processes reached",
      "root_cause": "beam_process_limit_error",
      "suggestion": "Check for process leaks where processes are created but not terminated. Consider using process pools or increasing the maximum number of processes with +P flag.",
      "confidence": "high",
      "severity": "critical",
      "category": "beam",
      "framework": "beam"
    }
  ]
}