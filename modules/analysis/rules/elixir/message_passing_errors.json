{
  "version": "1.0.0",
  "description": "Elixir message passing and process communication error detection rules",
  "rules": [
    {
      "id": "elixir_send_to_dead_process",
      "category": "message_passing",
      "type": "dead_process",
      "pattern": "sending to dead process|process .* is not alive|send returned {:badarg, _}",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Check if process is alive with Process.alive?/1 before sending",
      "root_cause": "elixir_send_dead_process",
      "tags": [
        "elixir",
        "send",
        "process",
        "dead"
      ],
      "description": "Send To Dead Process"
    },
    {
      "id": "elixir_mailbox_size_exceeded",
      "category": "message_passing",
      "type": "mailbox_overflow",
      "pattern": "mailbox size exceeded|message queue too large|process suspended.*mailbox full",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "critical",
      "suggestion": "Implement flow control or use GenStage for backpressure",
      "root_cause": "elixir_mailbox_overflow",
      "tags": [
        "elixir",
        "mailbox",
        "overflow",
        "memory"
      ],
      "description": "Mailbox Size Exceeded"
    },
    {
      "id": "elixir_receive_timeout_infinite_wait",
      "category": "message_passing",
      "type": "receive_timeout",
      "pattern": "receive without timeout|infinite wait in receive|process blocked forever",
      "confidence": "low",
      "reliability": "low",
      "severity": "medium",
      "suggestion": "Add after clause with timeout to receive blocks",
      "root_cause": "elixir_receive_no_timeout",
      "tags": [
        "elixir",
        "receive",
        "timeout",
        "blocking"
      ],
      "description": "Receive Timeout Infinite Wait"
    },
    {
      "id": "elixir_selective_receive_performance",
      "category": "message_passing",
      "type": "performance",
      "pattern": "selective receive.*slow|scanning large mailbox|receive pattern too specific",
      "confidence": "low",
      "reliability": "low",
      "severity": "medium",
      "suggestion": "Avoid selective receive with large mailboxes. Process messages in order",
      "root_cause": "elixir_selective_receive_slow",
      "tags": [
        "elixir",
        "receive",
        "performance",
        "selective"
      ],
      "description": "Selective Receive Performance"
    },
    {
      "id": "elixir_send_after_timer_error",
      "category": "message_passing",
      "type": "timer",
      "pattern": "Process.send_after.*failed|timer error|send_after to dead process",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Cancel timers with Process.cancel_timer/1 when process stops",
      "root_cause": "elixir_send_after_error",
      "tags": [
        "elixir",
        "timer",
        "send_after",
        "process"
      ],
      "description": "Send After Timer"
    },
    {
      "id": "elixir_monitor_dead_process",
      "category": "message_passing",
      "type": "monitor",
      "pattern": "monitoring dead process|monitor.*:noproc|Process.monitor.*already dead",
      "confidence": "high",
      "reliability": "high",
      "severity": "low",
      "suggestion": "Monitoring dead process immediately sends DOWN message",
      "root_cause": "elixir_monitor_dead",
      "tags": [
        "elixir",
        "monitor",
        "process",
        "dead"
      ],
      "description": "Monitor Dead Process"
    },
    {
      "id": "elixir_link_trap_exit_not_set",
      "category": "message_passing",
      "type": "link",
      "pattern": "linked process died.*terminated|exit signal not trapped|Process.link.*unexpected exit",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "high",
      "suggestion": "Set Process.flag(:trap_exit, true) to convert exit signals to messages",
      "root_cause": "elixir_link_no_trap_exit",
      "tags": [
        "elixir",
        "link",
        "exit",
        "trap"
      ],
      "description": "Link Trap Exit Not Set"
    },
    {
      "id": "elixir_distributed_send_node_down",
      "category": "message_passing",
      "type": "distributed",
      "pattern": "send to remote node failed|node.*is not connected|{:badarg, {:name, _, _}}",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Check Node.connect/1 and monitor nodes with Node.monitor/2",
      "root_cause": "elixir_distributed_send_failed",
      "tags": [
        "elixir",
        "distributed",
        "node",
        "send"
      ],
      "description": "Distributed Send Node Down"
    },
    {
      "id": "elixir_message_ordering_assumption",
      "category": "message_passing",
      "type": "ordering",
      "pattern": "message received out of order|unexpected message ordering|race condition.*messages",
      "confidence": "low",
      "reliability": "low",
      "severity": "medium",
      "suggestion": "Message order only guaranteed between pairs of processes",
      "root_cause": "elixir_message_order_assumption",
      "tags": [
        "elixir",
        "message",
        "ordering",
        "race"
      ],
      "description": "Message Ordering Assumption"
    },
    {
      "id": "elixir_process_register_conflict",
      "category": "message_passing",
      "type": "registration",
      "pattern": "Process.register.*already registered|name conflict|{:error, {:already_registered, _}}",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Check if name is registered with Process.whereis/1 before registering",
      "root_cause": "elixir_process_name_taken",
      "tags": [
        "elixir",
        "process",
        "register",
        "name"
      ],
      "description": "Process Register Conflict"
    },
    {
      "id": "elixir_receive_match_error",
      "category": "message_passing",
      "type": "pattern_match",
      "pattern": "no match.*receive clause|receive pattern match failed|message dropped.*no matching clause",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Add catch-all clause or ensure all message patterns are handled",
      "root_cause": "elixir_receive_no_match",
      "tags": [
        "elixir",
        "receive",
        "pattern",
        "match"
      ],
      "description": "Receive Match"
    },
    {
      "id": "elixir_process_info_dead_process",
      "category": "message_passing",
      "type": "introspection",
      "pattern": "Process.info.*returned nil|process info.*dead process|{:undefined, _} from process_info",
      "confidence": "high",
      "reliability": "high",
      "severity": "low",
      "suggestion": "Process.info/1 returns nil for dead processes",
      "root_cause": "elixir_process_info_nil",
      "tags": [
        "elixir",
        "process",
        "info",
        "dead"
      ],
      "description": "Process Info Dead Process"
    },
    {
      "id": "elixir_exit_signal_propagation",
      "category": "message_passing",
      "type": "exit_signal",
      "pattern": "exit signal propagated|linked process exit.*killed|cascading process exits",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "high",
      "suggestion": "Use supervisors or trap exits to control exit propagation",
      "root_cause": "elixir_exit_propagation",
      "tags": [
        "elixir",
        "exit",
        "link",
        "propagation"
      ],
      "description": "Exit Signal Propagation"
    },
    {
      "id": "elixir_call_timeout_vs_genserver",
      "category": "message_passing",
      "type": "timeout",
      "pattern": "Process.*call timeout|manual receive timeout.*GenServer better|implementing call pattern",
      "confidence": "low",
      "reliability": "low",
      "severity": "low",
      "suggestion": "Consider using GenServer instead of manual call/response patterns",
      "root_cause": "elixir_manual_call_pattern",
      "tags": [
        "elixir",
        "call",
        "timeout",
        "pattern"
      ],
      "description": "Call Timeout Vs Genserver"
    },
    {
      "id": "elixir_pg_process_group_error",
      "category": "message_passing",
      "type": "process_group",
      "pattern": ":pg.*failed|process group.*error|pg2 is deprecated.*use :pg",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Use :pg (not :pg2) for process groups in newer Elixir versions",
      "root_cause": "elixir_process_group_error",
      "tags": [
        "elixir",
        "pg",
        "process_group",
        "distributed"
      ],
      "description": "Pg Process Group"
    }
  ],
  "name": "Message Passing Errors"
}