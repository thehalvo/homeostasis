{
  "name": "Scala Common Errors",
  "rules": [
    {
      "id": "scala_null_pointer",
      "pattern": "java\\.lang\\.NullPointerException(?:: (.*))?",
      "type": "NullPointerException",
      "description": "Attempted to access or use a null object reference",
      "root_cause": "scala_null_pointer",
      "suggestion": "Add null checks before accessing objects or methods. Consider using Option[T] for values that might be null.",
      "confidence": "high",
      "severity": "high",
      "category": "core",
      "framework": "scala"
    },
    {
      "id": "scala_no_such_element",
      "pattern": "java\\.util\\.NoSuchElementException(?:: (.*))?",
      "type": "NoSuchElementException",
      "description": "Attempted to access a non-existent element, often with .head or .get on an empty collection",
      "root_cause": "scala_no_such_element",
      "suggestion": "Use .headOption instead of .head, or pattern matching with isEmpty/nonEmpty checks before accessing elements. Consider using getOrElse or fold for Option types.",
      "confidence": "high",
      "severity": "medium",
      "category": "collections",
      "framework": "scala"
    },
    {
      "id": "scala_match_error",
      "pattern": "scala\\.MatchError: (.*)",
      "type": "MatchError",
      "description": "Pattern match is not exhaustive, missing cases for some possible values",
      "root_cause": "scala_incomplete_match",
      "suggestion": "Ensure pattern matches cover all possible cases. Add a wildcard case (_) as fallback or use Option pattern matching for safer handling.",
      "confidence": "high",
      "severity": "medium",
      "category": "core",
      "framework": "scala"
    },
    {
      "id": "scala_index_out_of_bounds",
      "pattern": "java\\.lang\\.(ArrayIndexOutOfBoundsException|IndexOutOfBoundsException|StringIndexOutOfBoundsException): (\\d+)",
      "type": "IndexOutOfBoundsException",
      "description": "Attempted to access an array or collection element with an invalid index",
      "root_cause": "scala_index_out_of_bounds",
      "suggestion": "Check collection bounds before accessing elements with indices. Use collection.indices.contains(index) or lift/get to safely access elements.",
      "confidence": "high",
      "severity": "medium",
      "category": "collections",
      "framework": "scala"
    },
    {
      "id": "scala_class_cast",
      "pattern": "java\\.lang\\.ClassCastException: ([^\\s]+) cannot be cast to ([^\\s]+)",
      "type": "ClassCastException",
      "description": "Attempted to cast an object to an incompatible type",
      "root_cause": "scala_invalid_cast",
      "suggestion": "Verify object types before casting using match, isInstanceOf, or use pattern matching with type ascription. Consider better type design with sealed traits.",
      "confidence": "high",
      "severity": "medium",
      "category": "core",
      "framework": "scala"
    },
    {
      "id": "scala_option_empty",
      "pattern": "java\\.util\\.NoSuchElementException: None\\.get",
      "type": "NoSuchElementException",
      "description": "Called .get on an Option that is None",
      "root_cause": "scala_option_get_on_none",
      "suggestion": "Never call .get on an Option without first checking if it's defined. Use getOrElse, fold, or pattern matching instead.",
      "confidence": "high",
      "severity": "high",
      "category": "typesystem",
      "framework": "scala"
    },
    {
      "id": "scala_division_by_zero",
      "pattern": "java\\.lang\\.ArithmeticException: (/ by zero|Division by zero)",
      "type": "ArithmeticException",
      "description": "Attempted division by zero",
      "root_cause": "scala_division_by_zero",
      "suggestion": "Check for zero before division. Consider using Option to handle division operations safely.",
      "confidence": "high",
      "severity": "medium",
      "category": "core",
      "framework": "scala"
    },
    {
      "id": "scala_illegal_argument",
      "pattern": "java\\.lang\\.IllegalArgumentException: (.*)",
      "type": "IllegalArgumentException",
      "description": "A method received an argument that was not valid",
      "root_cause": "scala_invalid_argument",
      "suggestion": "Add parameter validation checks. Consider using require() for preconditions, or design with Option/Either to handle invalid inputs functionally.",
      "confidence": "medium",
      "severity": "medium",
      "category": "core",
      "framework": "scala"
    },
    {
      "id": "scala_illegal_state",
      "pattern": "java\\.lang\\.IllegalStateException: (.*)",
      "type": "IllegalStateException",
      "description": "Object is in an invalid state for the requested operation",
      "root_cause": "scala_invalid_state",
      "suggestion": "Check object state before performing operations. Consider using the State monad or immutable objects to prevent invalid state transitions.",
      "confidence": "medium",
      "severity": "medium",
      "category": "core",
      "framework": "scala"
    },
    {
      "id": "scala_parsing_error",
      "pattern": "scala\\.util\\.parsing\\.combinator\\.Parsers\\$Error: (.*)",
      "type": "Parser.Error",
      "description": "Error during parsing with the Scala parser combinators",
      "root_cause": "scala_parser_error",
      "suggestion": "Check the input being parsed and ensure it matches the grammar. Improve error reporting with custom parsers.",
      "confidence": "medium",
      "severity": "medium",
      "category": "core",
      "framework": "scala"
    },
    {
      "id": "scala_stack_overflow",
      "pattern": "java\\.lang\\.StackOverflowError(?:: (.*))?",
      "type": "StackOverflowError",
      "description": "Recursive function calls exceeded the stack size, typically due to infinite recursion",
      "root_cause": "scala_stack_overflow",
      "suggestion": "Check for proper recursion termination conditions. Consider using tail recursion with the @tailrec annotation or convert to an iterative approach.",
      "confidence": "high",
      "severity": "high",
      "category": "core",
      "framework": "scala"
    },
    {
      "id": "scala_out_of_memory",
      "pattern": "java\\.lang\\.OutOfMemoryError: (.*)",
      "type": "OutOfMemoryError",
      "description": "JVM ran out of memory",
      "root_cause": "scala_out_of_memory",
      "suggestion": "Increase JVM heap size (-Xmx), check for memory leaks, or optimize memory-intensive operations. Consider using streams for large data processing.",
      "confidence": "high",
      "severity": "critical",
      "category": "jvm",
      "framework": "scala"
    },
    {
      "id": "scala_type_mismatch",
      "pattern": "scala\\.reflect\\.internal\\.FatalError: type mismatch",
      "type": "FatalError",
      "description": "Type mismatch error at runtime, likely due to macro expansion or reflection",
      "root_cause": "scala_type_mismatch",
      "suggestion": "Check type parameters and ensure types are compatible. Review implicit conversions and type classes.",
      "confidence": "medium",
      "severity": "high",
      "category": "typesystem",
      "framework": "scala"
    },
    {
      "id": "scala_number_format",
      "pattern": "java\\.lang\\.NumberFormatException: (.*)",
      "type": "NumberFormatException",
      "description": "Failed to parse a string as a number",
      "root_cause": "scala_invalid_number_format",
      "suggestion": "Ensure the string represents a valid number. Use scala.util.Try with toInt/toLong/toDouble or use a validation library like Validated from Cats.",
      "confidence": "high",
      "severity": "medium",
      "category": "core",
      "framework": "scala"
    },
    {
      "id": "scala_assertion_error",
      "pattern": "java\\.lang\\.AssertionError: (.*)",
      "type": "AssertionError",
      "description": "An assertion has failed",
      "root_cause": "scala_assertion_failed",
      "suggestion": "Check the condition that caused the assertion to fail. Assertions should only check invariants, not user input.",
      "confidence": "high",
      "severity": "high",
      "category": "core",
      "framework": "scala"
    },
    {
      "id": "scala_unsupported_operation",
      "pattern": "java\\.lang\\.UnsupportedOperationException: (.*)",
      "type": "UnsupportedOperationException",
      "description": "The requested operation is not supported by this object",
      "root_cause": "scala_unsupported_operation",
      "suggestion": "Check if the object supports the operation before calling it. Common with immutable collections or views.",
      "confidence": "high",
      "severity": "medium",
      "category": "core",
      "framework": "scala"
    },
    {
      "id": "scala_abstract_method_error",
      "pattern": "java\\.lang\\.AbstractMethodError: (.*)",
      "type": "AbstractMethodError",
      "description": "Attempted to call an abstract method that has not been implemented",
      "root_cause": "scala_abstract_method_not_implemented",
      "suggestion": "Implement the abstract method in all subclasses, or make the class abstract. Check for binary compatibility issues after library updates.",
      "confidence": "high",
      "severity": "high",
      "category": "core",
      "framework": "scala"
    },
    {
      "id": "scala_reflective_compilation_error",
      "pattern": "scala\\.reflect\\.macros\\.internal\\.reflect\\..*?(Error|Exception): (.*)",
      "type": "ReflectiveCompilationException",
      "description": "Error during compile-time reflection or macro expansion",
      "root_cause": "scala_reflective_compilation_error",
      "suggestion": "Check macro implementations and context bounds. Ensure type parameters are correctly specified and required implicit values are available.",
      "confidence": "medium",
      "severity": "high",
      "category": "typesystem",
      "framework": "scala"
    },
    {
      "id": "scala_implicit_not_found",
      "pattern": "could not find implicit value for parameter [^:]+: (.*)",
      "type": "ImplicitNotFound",
      "description": "The compiler could not find an implicit value of the required type",
      "root_cause": "scala_implicit_not_found",
      "suggestion": "Ensure the required implicit is in scope. Import companion objects containing implicits, or explicitly define the missing implicit instance.",
      "confidence": "high",
      "severity": "medium",
      "category": "typesystem",
      "framework": "scala"
    },
    {
      "id": "scala_diverging_implicit",
      "pattern": "diverging implicit expansion for type (.*)",
      "type": "DivergingImplicit",
      "description": "The implicit resolution process entered an infinite loop",
      "root_cause": "scala_diverging_implicit",
      "suggestion": "Check for recursive implicit definitions. Provide more specific implicit instances to help guide the compiler's resolution process.",
      "confidence": "high",
      "severity": "high",
      "category": "typesystem",
      "framework": "scala"
    }
  ]
}