{
  "version": "1.0.0",
  "description": "Scala implicit resolution and type class error detection rules",
  "rules": [
    {
      "id": "scala_ambiguous_implicit_values",
      "category": "implicits",
      "type": "ambiguous",
      "pattern": "ambiguous implicit values|both .* and .* match expected type",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Disambiguate by importing specific implicit, using explicit parameter, or adjusting implicit priority",
      "root_cause": "scala_implicit_ambiguity",
      "tags": ["scala", "implicit", "ambiguous", "resolution"]
    },
    {
      "id": "scala_implicit_conversion_not_applicable",
      "category": "implicits",
      "type": "conversion",
      "pattern": "implicit conversion .* is not applicable|type mismatch.*Note that implicit conversions",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Import required implicit conversion or define one. Enable with import scala.language.implicitConversions",
      "root_cause": "scala_implicit_conversion_missing",
      "tags": ["scala", "implicit", "conversion", "type"]
    },
    {
      "id": "scala_context_bound_not_satisfied",
      "category": "implicits",
      "type": "context_bound",
      "pattern": "could not find implicit value for evidence parameter of type|No implicit view available from .* => .*",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Provide implicit instance for the required type class or import it into scope",
      "root_cause": "scala_context_bound_missing",
      "tags": ["scala", "implicit", "context_bound", "evidence"]
    },
    {
      "id": "scala_type_class_derivation_failed",
      "category": "implicits",
      "type": "type_class",
      "pattern": "could not derive instance of type class|magnolia: could not derive|shapeless: could not derive",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "high",
      "suggestion": "Ensure all components have type class instances or provide custom instance",
      "root_cause": "scala_type_class_derivation",
      "tags": ["scala", "implicit", "type_class", "derivation"]
    },
    {
      "id": "scala_implicit_not_found_custom",
      "category": "implicits",
      "type": "not_found",
      "pattern": "@implicitNotFound|could not find implicit value.*@implicitNotFound",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Follow the custom error message provided by @implicitNotFound annotation",
      "root_cause": "scala_implicit_not_found_annotated",
      "tags": ["scala", "implicit", "not_found", "annotation"]
    },
    {
      "id": "scala_implicit_priority_shadowing",
      "category": "implicits",
      "type": "priority",
      "pattern": "implicit .* is shadowed by .* in scope|lower priority implicit .* is selected",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Understand implicit priority rules: local > imported > inherited > package object",
      "root_cause": "scala_implicit_priority",
      "tags": ["scala", "implicit", "priority", "shadowing"]
    },
    {
      "id": "scala_implicit_scope_issue",
      "category": "implicits",
      "type": "scope",
      "pattern": "implicit .* is not applicable here|implicit value .* is not a member of",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Ensure implicit is in scope: companion object, import, or local definition",
      "root_cause": "scala_implicit_out_of_scope",
      "tags": ["scala", "implicit", "scope", "visibility"]
    },
    {
      "id": "scala_diverging_implicit_expansion",
      "category": "implicits",
      "type": "diverging",
      "pattern": "diverging implicit expansion|implicit search has recursed too deeply",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Break recursive implicit resolution with explicit type annotations or Lazy wrapper",
      "root_cause": "scala_implicit_diverging",
      "tags": ["scala", "implicit", "diverging", "recursive"]
    },
    {
      "id": "scala_implicit_class_not_found",
      "category": "implicits",
      "type": "implicit_class",
      "pattern": "value .* is not a member of|implicit class .* is not applicable",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Import the implicit class or ensure it's in companion object of target type",
      "root_cause": "scala_implicit_class_missing",
      "tags": ["scala", "implicit", "class", "extension"]
    },
    {
      "id": "scala_aux_pattern_type_mismatch",
      "category": "implicits",
      "type": "aux_pattern",
      "pattern": "type mismatch.*Aux.*found.*required|could not find implicit value.*\\.Aux\\[",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Ensure Aux pattern type members align: Foo.Aux[A, B] matches Foo[A] { type Out = B }",
      "root_cause": "scala_aux_pattern_mismatch",
      "tags": ["scala", "implicit", "aux", "type_member"]
    },
    {
      "id": "scala_implicit_macro_expansion_failed",
      "category": "implicits",
      "type": "macro",
      "pattern": "implicit macro expansion failed|exception during macro expansion",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Check macro implementation for errors, ensure macro paradise plugin if needed",
      "root_cause": "scala_implicit_macro_failed",
      "tags": ["scala", "implicit", "macro", "expansion"]
    },
    {
      "id": "scala_implicit_parameter_explicit",
      "category": "implicits",
      "type": "parameter",
      "pattern": "not enough arguments for method.*implicit|missing implicit parameter",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Provide implicit parameter explicitly or ensure implicit value is in scope",
      "root_cause": "scala_implicit_parameter_missing",
      "tags": ["scala", "implicit", "parameter", "argument"]
    },
    {
      "id": "scala_view_bound_deprecated",
      "category": "implicits",
      "type": "view_bound",
      "pattern": "view bounds are deprecated|<%.*is deprecated.*use an implicit parameter",
      "confidence": "high",
      "reliability": "high",
      "severity": "low",
      "suggestion": "Replace view bounds (A <% B) with context bounds or implicit parameters",
      "root_cause": "scala_view_bound_deprecated",
      "tags": ["scala", "implicit", "view_bound", "deprecated"]
    },
    {
      "id": "scala_implicit_def_recursion",
      "category": "implicits",
      "type": "recursive_def",
      "pattern": "recursive implicit def .* needs result type|cyclic reference involving implicit",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Add explicit result type to recursive implicit def",
      "root_cause": "scala_implicit_recursive_def",
      "tags": ["scala", "implicit", "recursive", "def"]
    },
    {
      "id": "scala_magnet_pattern_overload",
      "category": "implicits",
      "type": "magnet",
      "pattern": "magnet pattern.*ambiguous|too many arguments for method.*magnet",
      "confidence": "low",
      "reliability": "low",
      "severity": "medium",
      "suggestion": "Magnet pattern can cause ambiguity. Consider alternative overloading strategies",
      "root_cause": "scala_magnet_pattern",
      "tags": ["scala", "implicit", "magnet", "overload"]
    }
  ]
}