{
  "version": "1.0.0",
  "description": "Scala type system and variance error detection rules",
  "rules": [
    {
      "id": "scala_covariance_violation",
      "category": "type_variance",
      "type": "covariance",
      "pattern": "covariant type .* occurs in contravariant position|type .* is declared as covariant, but appears in contravariant position",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Covariant types (+T) can only appear in output positions. Use contravariance (-T) for input positions",
      "root_cause": "scala_covariance_position",
      "tags": ["scala", "variance", "covariant", "type"]
    },
    {
      "id": "scala_contravariance_violation",
      "category": "type_variance",
      "type": "contravariance",
      "pattern": "contravariant type .* occurs in covariant position|type .* is declared as contravariant, but appears in covariant position",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Contravariant types (-T) can only appear in input positions. Use covariance (+T) for output positions",
      "root_cause": "scala_contravariance_position",
      "tags": ["scala", "variance", "contravariant", "type"]
    },
    {
      "id": "scala_invariant_type_expected",
      "category": "type_variance",
      "type": "invariance",
      "pattern": "invariant type .* in .*variant context|type .* is invariant, but .* is expected",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Invariant types cannot be used where variant types are expected. Consider using wildcards or type bounds",
      "root_cause": "scala_invariant_context",
      "tags": ["scala", "variance", "invariant", "type"]
    },
    {
      "id": "scala_type_bound_violation",
      "category": "type_bounds",
      "type": "bounds",
      "pattern": "type arguments .* do not conform to .* bounds|type .* does not satisfy .* bound",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Ensure type parameters satisfy upper (<:) and lower (>:) bounds",
      "root_cause": "scala_type_bound_not_satisfied",
      "tags": ["scala", "type", "bounds", "constraint"]
    },
    {
      "id": "scala_f_bounded_polymorphism",
      "category": "type_bounds",
      "type": "f_bounded",
      "pattern": "F-bounded type .* does not conform|recursive type bound violation",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "F-bounded types must reference themselves correctly: trait F[A <: F[A]]",
      "root_cause": "scala_f_bounded_error",
      "tags": ["scala", "type", "f_bounded", "recursive"]
    },
    {
      "id": "scala_higher_kinded_type_error",
      "category": "higher_kinded",
      "type": "hkt",
      "pattern": ".* takes type parameters|higher-kinded type .* used without parameters|kind mismatch",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Higher-kinded types need type parameters: F[_] for type constructors",
      "root_cause": "scala_hkt_parameter_missing",
      "tags": ["scala", "type", "higher_kinded", "parameter"]
    },
    {
      "id": "scala_type_projection_error",
      "category": "type_projection",
      "type": "projection",
      "pattern": "type projection .* is not a legal prefix|illegal type selection from volatile type",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Type projections T#U require stable prefixes. Use path-dependent types or type aliases",
      "root_cause": "scala_type_projection_volatile",
      "tags": ["scala", "type", "projection", "path"]
    },
    {
      "id": "scala_path_dependent_type_error",
      "category": "path_dependent",
      "type": "path",
      "pattern": "type .* is not a member of|path-dependent type .* cannot be instantiated",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Path-dependent types require stable paths. Ensure the path is properly initialized",
      "root_cause": "scala_path_dependent_invalid",
      "tags": ["scala", "type", "path_dependent", "member"]
    },
    {
      "id": "scala_existential_type_warning",
      "category": "existential",
      "type": "existential",
      "pattern": "existential type .* is deprecated|inferred existential type .*, which cannot be expressed by wildcards",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "low",
      "suggestion": "Replace existential types with wildcards (_) or proper type parameters",
      "root_cause": "scala_existential_deprecated",
      "tags": ["scala", "type", "existential", "deprecated"]
    },
    {
      "id": "scala_type_lambda_error",
      "category": "type_lambda",
      "type": "lambda",
      "pattern": "type lambda .* is malformed|cannot parse type lambda|kind-projector syntax error",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Use proper type lambda syntax or kind-projector plugin: ({type λ[α] = F[α]})#λ",
      "root_cause": "scala_type_lambda_syntax",
      "tags": ["scala", "type", "lambda", "syntax"]
    },
    {
      "id": "scala_wildcard_type_capture",
      "category": "wildcard",
      "type": "capture",
      "pattern": "wildcard type .* cannot be captured|existential .* escapes its scope",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Wildcard types cannot escape their defining scope. Use named type parameters",
      "root_cause": "scala_wildcard_escape",
      "tags": ["scala", "type", "wildcard", "existential"]
    },
    {
      "id": "scala_type_alias_cycle",
      "category": "type_alias",
      "type": "cycle",
      "pattern": "cyclic aliasing or subtyping involving type|illegal cyclic reference involving type",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Remove circular dependencies in type alias definitions",
      "root_cause": "scala_type_alias_cyclic",
      "tags": ["scala", "type", "alias", "cycle"]
    },
    {
      "id": "scala_structural_type_reflection",
      "category": "structural",
      "type": "reflection",
      "pattern": "reflective access of structural type member .* should be enabled|structural type .* requires reflection",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "low",
      "suggestion": "Enable reflective calls with import scala.language.reflectiveCalls or avoid structural types",
      "root_cause": "scala_structural_reflection",
      "tags": ["scala", "type", "structural", "reflection"]
    },
    {
      "id": "scala_type_erasure_warning",
      "category": "erasure",
      "type": "erasure",
      "pattern": "abstract type .* is unchecked since it is eliminated by erasure|type pattern .* is unchecked",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Type parameters are erased at runtime. Use ClassTag or TypeTag for runtime type information",
      "root_cause": "scala_type_erasure",
      "tags": ["scala", "type", "erasure", "runtime"]
    },
    {
      "id": "scala_variance_annotation_position",
      "category": "variance_annotation",
      "type": "position",
      "pattern": "variance annotation .* not allowed here|.* variance annotation is only allowed for type parameters",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Variance annotations (+/-) are only allowed on type parameters of classes and traits",
      "root_cause": "scala_variance_annotation_invalid",
      "tags": ["scala", "variance", "annotation", "position"]
    }
  ]
}