{
  "version": "1.0.0",
  "description": "Common Swift error detection rules",
  "rules": [
    {
      "id": "swift_force_unwrap_nil",
      "category": "optionals",
      "type": "force_unwrap",
      "pattern": "fatal error: unexpectedly found nil while unwrapping an Optional value",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Replace force unwrapping (!) with safe unwrapping using if let, guard let, or nil coalescing operator (??)",
      "root_cause": "swift_force_unwrap_nil",
      "tags": ["swift", "optionals", "fatal", "nil"]
    },
    {
      "id": "swift_array_index_bounds",
      "category": "collections",
      "type": "index_out_of_bounds",
      "pattern": "fatal error: Index out of range",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Check array bounds before accessing elements using array.indices.contains(index)",
      "root_cause": "swift_array_index_out_of_bounds",
      "tags": ["swift", "array", "bounds", "fatal"]
    },
    {
      "id": "swift_dictionary_key_not_found",
      "category": "collections",
      "type": "key_not_found",
      "pattern": "fatal error: Dictionary key not found",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Use optional subscripting dictionary[key] or provide default with dictionary[key, default: value]",
      "root_cause": "swift_dictionary_key_not_found",
      "tags": ["swift", "dictionary", "key", "optional"]
    },
    {
      "id": "swift_exc_bad_access",
      "category": "memory",
      "type": "memory_access",
      "pattern": "EXC_BAD_ACCESS",
      "confidence": "high",
      "reliability": "high",
      "severity": "critical",
      "suggestion": "Memory access violation - check for retain cycles, dangling pointers, or accessing deallocated objects",
      "root_cause": "swift_exc_bad_access",
      "tags": ["swift", "memory", "crash", "access"]
    },
    {
      "id": "swift_thread_sanitizer_race",
      "category": "concurrency",
      "type": "data_race",
      "pattern": "ThreadSanitizer: data race",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Data race detected - ensure proper synchronization using locks, actors, or async/await",
      "root_cause": "swift_data_race",
      "tags": ["swift", "concurrency", "race", "threading"]
    },
    {
      "id": "swift_main_thread_checker",
      "category": "threading",
      "type": "main_thread_violation",
      "pattern": "Main Thread Checker: UI API called on a background thread",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "UI updates must be performed on the main thread - use DispatchQueue.main.async or @MainActor",
      "root_cause": "swift_main_thread_violation",
      "tags": ["swift", "ui", "threading", "main_thread"]
    },
    {
      "id": "swift_weak_reference_cycle",
      "category": "memory",
      "type": "retain_cycle",
      "pattern": "retain cycle|memory leak",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Use [weak self] or [unowned self] in closures to break retain cycles",
      "root_cause": "swift_weak_reference_cycle",
      "tags": ["swift", "memory", "cycle", "closure"]
    },
    {
      "id": "swift_optional_chaining_error",
      "category": "optionals",
      "type": "optional_chaining",
      "pattern": "Cannot force unwrap value of non-optional type",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Remove force unwrapping operator (!) or ensure the value is actually optional",
      "root_cause": "swift_invalid_force_unwrap",
      "tags": ["swift", "optionals", "unwrap", "type"]
    },
    {
      "id": "swift_string_interpolation_error",
      "category": "core",
      "type": "string_interpolation",
      "pattern": "String interpolation produces a debug description",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "low",
      "suggestion": "Ensure objects in string interpolation conform to CustomStringConvertible",
      "root_cause": "swift_string_interpolation_debug",
      "tags": ["swift", "string", "interpolation", "debug"]
    },
    {
      "id": "swift_async_operation_cancelled",
      "category": "concurrency",
      "type": "task_cancellation",
      "pattern": "Task was cancelled|CancellationError",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Handle task cancellation gracefully with try Task.checkCancellation() or catch CancellationError",
      "root_cause": "swift_task_cancelled",
      "tags": ["swift", "async", "cancellation", "task"]
    },
    {
      "id": "swift_deadlock_detection",
      "category": "concurrency",
      "type": "deadlock",
      "pattern": "deadlock|Thread \\d+: signal SIGKILL",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "critical",
      "suggestion": "Deadlock detected - review synchronization code and avoid nested locks",
      "root_cause": "swift_deadlock",
      "tags": ["swift", "deadlock", "concurrency", "lock"]
    },
    {
      "id": "swift_nsobject_dealloc_error",
      "category": "memory",
      "type": "dealloc_error",
      "pattern": "message sent to deallocated instance",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Accessing deallocated object - check object lifecycle and weak references",
      "root_cause": "swift_deallocated_object_access",
      "tags": ["swift", "memory", "dealloc", "lifecycle"]
    },
    {
      "id": "swift_casting_failure",
      "category": "core",
      "type": "type_casting",
      "pattern": "Could not cast value.*to.*NSString",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Type casting failed - use conditional casting (as?) or ensure type compatibility",
      "root_cause": "swift_type_casting_failure",
      "tags": ["swift", "casting", "type", "nsobject"]
    },
    {
      "id": "swift_precondition_failure",
      "category": "core",
      "type": "precondition",
      "pattern": "Precondition failed",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Precondition failed - review the failing condition and ensure valid input",
      "root_cause": "swift_precondition_failure",
      "tags": ["swift", "precondition", "assert", "validation"]
    },
    {
      "id": "swift_fatalError_call",
      "category": "core",
      "type": "fatal_error",
      "pattern": "fatal error:",
      "confidence": "high",
      "reliability": "high",
      "severity": "critical",
      "suggestion": "Review the fatal error condition and implement proper error handling",
      "root_cause": "swift_fatal_error",
      "tags": ["swift", "fatal", "error", "crash"]
    }
  ]
}