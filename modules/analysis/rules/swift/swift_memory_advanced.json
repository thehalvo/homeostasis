{
  "name": "Swift Swift Memory Advanced",
  "version": "1.0.0",
  "description": "Advanced Swift memory management error detection rules",
  "rules": [
    {
      "id": "swift_unowned_reference_crash",
      "category": "memory",
      "type": "unowned_crash",
      "pattern": "Fatal error: Attempted to read an unowned reference but object was already deallocated",
      "confidence": "high",
      "reliability": "high",
      "severity": "critical",
      "suggestion": "Use weak references instead of unowned when the referenced object might be deallocated. Always verify object lifetime",
      "root_cause": "swift_unowned_deallocated",
      "tags": [
        "swift",
        "memory",
        "unowned",
        "crash"
      ],
      "description": "Swift Unowned Reference Crash"
    },
    {
      "id": "swift_weak_strong_dance_error",
      "category": "memory",
      "type": "weak_strong",
      "pattern": "Variable '.*' was written to, but never read|Immutable value '.*' was never used",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "low",
      "suggestion": "After guard let strongSelf = self, use strongSelf consistently throughout the closure",
      "root_cause": "swift_weak_strong_pattern",
      "tags": [
        "swift",
        "memory",
        "weak",
        "closure"
      ],
      "description": "Swift Weak Strong Dance"
    },
    {
      "id": "swift_capture_list_missing",
      "category": "memory",
      "type": "capture_list",
      "pattern": "Reference to property '.*' in closure requires explicit use of 'self'|Escaping closure captures",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Add explicit capture list [weak self] or [unowned self] to prevent retain cycles",
      "root_cause": "swift_missing_capture_list",
      "tags": [
        "swift",
        "memory",
        "capture",
        "closure"
      ],
      "description": "Swift Capture List Missing"
    },
    {
      "id": "swift_multiple_capture_semantics",
      "category": "memory",
      "type": "capture_semantics",
      "pattern": "Cannot capture '.*' before it is declared|Multiple closures with implicit capture",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Be explicit about capture semantics when multiple closures capture the same variable",
      "root_cause": "swift_capture_semantics",
      "tags": [
        "swift",
        "memory",
        "capture",
        "multiple"
      ],
      "description": "Swift Multiple Capture Semantics"
    },
    {
      "id": "swift_delegate_retain_cycle",
      "category": "memory",
      "type": "delegate_cycle",
      "pattern": "Class '.*' has a strong reference to its delegate|Potential retain cycle detected",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "high",
      "suggestion": "Delegates should be declared as weak var to prevent retain cycles",
      "root_cause": "swift_strong_delegate",
      "tags": [
        "swift",
        "memory",
        "delegate",
        "cycle"
      ],
      "description": "Swift Delegate Retain Cycle"
    },
    {
      "id": "swift_closure_self_reference",
      "category": "memory",
      "type": "self_reference",
      "pattern": "Reference to member '.*' cannot be resolved without a contextual type|Call to method '.*' in closure requires explicit use of 'self'",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Use explicit self. in closures or add to capture list to make memory semantics clear",
      "root_cause": "swift_implicit_self_capture",
      "tags": [
        "swift",
        "memory",
        "self",
        "closure"
      ],
      "description": "Swift Closure Self Reference"
    },
    {
      "id": "swift_value_type_reference_cycle",
      "category": "memory",
      "type": "value_reference_cycle",
      "pattern": "Struct '.*' cannot be recursive|Value type '.*' cannot have a stored property that recursively contains it",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Use indirect enum cases or reference types to break recursion in value types",
      "root_cause": "swift_recursive_value_type",
      "tags": [
        "swift",
        "memory",
        "struct",
        "recursive"
      ],
      "description": "Swift Value Type Reference Cycle"
    },
    {
      "id": "swift_autoreleasepool_missing",
      "category": "memory",
      "type": "autorelease",
      "pattern": "Memory usage is increasing|Temporary objects not being released",
      "confidence": "low",
      "reliability": "low",
      "severity": "medium",
      "suggestion": "Use autoreleasepool { } in loops that create many temporary objects",
      "root_cause": "swift_autorelease_accumulation",
      "tags": [
        "swift",
        "memory",
        "autoreleasepool",
        "temporary"
      ],
      "description": "Swift Autoreleasepool Missing"
    },
    {
      "id": "swift_copy_on_write_unexpected",
      "category": "memory",
      "type": "cow_behavior",
      "pattern": "Simultaneous accesses to .*, but modification requires exclusive access|Unexpected copying of value type",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Understand copy-on-write behavior for Array, Dictionary, Set. Use isKnownUniquelyReferenced for custom COW types",
      "root_cause": "swift_cow_exclusive_access",
      "tags": [
        "swift",
        "memory",
        "cow",
        "exclusive"
      ],
      "description": "Swift Copy On Write Unexpected"
    },
    {
      "id": "swift_unsafe_pointer_misuse",
      "category": "memory",
      "type": "unsafe_pointer",
      "pattern": "Use of uninitialized memory|Unsafe pointer argument must not be deallocated",
      "confidence": "high",
      "reliability": "high",
      "severity": "critical",
      "suggestion": "Ensure proper initialization and lifetime management when using unsafe pointers",
      "root_cause": "swift_unsafe_pointer",
      "tags": [
        "swift",
        "memory",
        "unsafe",
        "pointer"
      ],
      "description": "Swift Unsafe Pointer Misuse"
    },
    {
      "id": "swift_escaping_closure_lifetime",
      "category": "memory",
      "type": "escaping_closure",
      "pattern": "Escaping closure captures non-escaping parameter|Parameter '.*' is implicitly non-escaping",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Mark closure parameter as @escaping if it outlives the function call",
      "root_cause": "swift_escaping_lifetime",
      "tags": [
        "swift",
        "memory",
        "escaping",
        "closure"
      ],
      "description": "Swift Escaping Closure Lifetime"
    },
    {
      "id": "swift_actor_isolation_memory",
      "category": "memory",
      "type": "actor_isolation",
      "pattern": "Actor-isolated property '.*' cannot be referenced from a non-isolated context",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Access actor-isolated state through async methods or within the actor's context",
      "root_cause": "swift_actor_memory_isolation",
      "tags": [
        "swift",
        "memory",
        "actor",
        "isolation"
      ],
      "description": "Swift Actor Isolation Memory"
    },
    {
      "id": "swift_reference_counting_overflow",
      "category": "memory",
      "type": "refcount_overflow",
      "pattern": "Object reference count overflow|Too many strong references",
      "confidence": "low",
      "reliability": "low",
      "severity": "critical",
      "suggestion": "Review object graph for excessive retain counts or circular references",
      "root_cause": "swift_refcount_overflow",
      "tags": [
        "swift",
        "memory",
        "refcount",
        "overflow"
      ],
      "description": "Swift Reference Counting Overflow"
    },
    {
      "id": "swift_deinit_not_called",
      "category": "memory",
      "type": "deinit_lifecycle",
      "pattern": "deinit was not called|Memory leak detected|Object still allocated",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "high",
      "suggestion": "Check for retain cycles preventing deinitialization. Use memory graph debugger",
      "root_cause": "swift_deinit_not_called",
      "tags": [
        "swift",
        "memory",
        "deinit",
        "leak"
      ],
      "description": "Swift Deinit Not Called"
    },
    {
      "id": "swift_notification_observer_leak",
      "category": "memory",
      "type": "notification_observer",
      "pattern": "NotificationCenter observer was not removed|Notification observer causing retain cycle",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Remove notification observers in deinit or use weak references in closure-based observers",
      "root_cause": "swift_notification_observer_leak",
      "tags": [
        "swift",
        "memory",
        "notification",
        "observer"
      ],
      "description": "Swift Notification Observer Leak"
    }
  ]
}