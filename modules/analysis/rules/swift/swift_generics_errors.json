{
  "name": "Swift Swift Generics Errors",
  "version": "1.0.0",
  "description": "Swift generic programming error detection rules",
  "rules": [
    {
      "id": "swift_generic_constraint_failure",
      "category": "generics",
      "type": "constraint",
      "pattern": "Type '.*' does not conform to protocol '.*'|Generic parameter '.*' could not be inferred",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Ensure type arguments satisfy all generic constraints. Add explicit type annotations if inference fails",
      "root_cause": "swift_generic_constraint",
      "tags": [
        "swift",
        "generics",
        "constraint",
        "conformance"
      ],
      "description": "Swift Generic Constraint Failure"
    },
    {
      "id": "swift_generic_type_inference_failure",
      "category": "generics",
      "type": "inference",
      "pattern": "Cannot infer type parameter '.*'|Generic parameter '.*' could not be inferred",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Provide explicit type parameters or add more context for type inference",
      "root_cause": "swift_generic_inference",
      "tags": [
        "swift",
        "generics",
        "inference",
        "type"
      ],
      "description": "Swift Generic Type Inference Failure"
    },
    {
      "id": "swift_generic_where_clause_conflict",
      "category": "generics",
      "type": "where_clause",
      "pattern": "Conflicting requirements for generic parameter|Where clause cannot be satisfied",
      "confidence": "high",
      "reliability": "high",
      "severity": "high",
      "suggestion": "Review where clause constraints for conflicts or impossible requirements",
      "root_cause": "swift_generic_where_conflict",
      "tags": [
        "swift",
        "generics",
        "where",
        "conflict"
      ],
      "description": "Swift Generic Where Clause Conflict"
    },
    {
      "id": "swift_generic_associated_type_mismatch",
      "category": "generics",
      "type": "associated_type",
      "pattern": "Cannot convert value of type '.*' to expected argument type '.*\\..*'",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Ensure associated types match when using generic protocols",
      "root_cause": "swift_generic_associated_type",
      "tags": [
        "swift",
        "generics",
        "associated",
        "protocol"
      ],
      "description": "Swift Generic Associated Type Mismatch"
    },
    {
      "id": "swift_generic_variance_error",
      "category": "generics",
      "type": "variance",
      "pattern": "Cannot convert value of type '\\[.*\\]' to expected argument type '\\[.*\\]'",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Swift generics are invariant. Cannot pass [Subclass] where [Superclass] is expected",
      "root_cause": "swift_generic_variance",
      "tags": [
        "swift",
        "generics",
        "variance",
        "covariance"
      ],
      "description": "Swift Generic Variance"
    },
    {
      "id": "swift_generic_function_ambiguity",
      "category": "generics",
      "type": "overload_ambiguity",
      "pattern": "Ambiguous use of '.*'|Cannot infer contextual base in reference to member",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Disambiguate generic function calls with explicit type parameters or type context",
      "root_cause": "swift_generic_ambiguity",
      "tags": [
        "swift",
        "generics",
        "ambiguity",
        "overload"
      ],
      "description": "Swift Generic Function Ambiguity"
    },
    {
      "id": "swift_generic_metatype_error",
      "category": "generics",
      "type": "metatype",
      "pattern": "Cannot convert value of type '.*\\.Type' to expected argument type '.*\\.Type'",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Use type(of:) or .self appropriately when working with metatypes in generic contexts",
      "root_cause": "swift_generic_metatype",
      "tags": [
        "swift",
        "generics",
        "metatype",
        "type"
      ],
      "description": "Swift Generic Metatype"
    },
    {
      "id": "swift_generic_existential_limitation",
      "category": "generics",
      "type": "existential",
      "pattern": "Protocol '.*' can only be used as a generic constraint because it has Self or associated type requirements",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Use generic constraints or type erasure for protocols with associated types",
      "root_cause": "swift_generic_existential",
      "tags": [
        "swift",
        "generics",
        "existential",
        "protocol"
      ],
      "description": "Swift Generic Existential Limitation"
    },
    {
      "id": "swift_generic_recursive_constraint",
      "category": "generics",
      "type": "recursive",
      "pattern": "Recursive generic parameter constraint|Circular reference in generic constraints",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "high",
      "suggestion": "Avoid circular dependencies in generic constraints",
      "root_cause": "swift_generic_recursive",
      "tags": [
        "swift",
        "generics",
        "recursive",
        "circular"
      ],
      "description": "Swift Generic Recursive Constraint"
    },
    {
      "id": "swift_generic_conditional_conformance_missing",
      "category": "generics",
      "type": "conditional_conformance",
      "pattern": "Conditional conformance of type '.*' to protocol '.*' does not imply conformance",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Check if conditional conformance requirements are met for this specific type",
      "root_cause": "swift_generic_conditional",
      "tags": [
        "swift",
        "generics",
        "conditional",
        "conformance"
      ],
      "description": "Swift Generic Conditional Conformance Missing"
    },
    {
      "id": "swift_generic_opaque_type_error",
      "category": "generics",
      "type": "opaque_type",
      "pattern": "Cannot convert return expression of type '.*' to return type 'some .*'",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Ensure consistent return type when using opaque return types (some Protocol)",
      "root_cause": "swift_generic_opaque",
      "tags": [
        "swift",
        "generics",
        "opaque",
        "some"
      ],
      "description": "Swift Generic Opaque Type"
    },
    {
      "id": "swift_generic_type_erasure_needed",
      "category": "generics",
      "type": "type_erasure",
      "pattern": "Heterogeneous collection literal could only be inferred to '\\[Any\\]'",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "low",
      "suggestion": "Use type erasure wrapper (like AnySequence) for heterogeneous collections of protocol types",
      "root_cause": "swift_generic_erasure",
      "tags": [
        "swift",
        "generics",
        "erasure",
        "any"
      ],
      "description": "Swift Generic Type Erasure Needed"
    },
    {
      "id": "swift_generic_specialization_error",
      "category": "generics",
      "type": "specialization",
      "pattern": "Generic specialization of '.*' is not allowed",
      "confidence": "high",
      "reliability": "high",
      "severity": "medium",
      "suggestion": "Swift doesn't support explicit generic specialization. Use type aliases or wrapper types",
      "root_cause": "swift_generic_specialization",
      "tags": [
        "swift",
        "generics",
        "specialization",
        "explicit"
      ],
      "description": "Swift Generic Specialization"
    },
    {
      "id": "swift_generic_phantom_type",
      "category": "generics",
      "type": "phantom_type",
      "pattern": "Generic parameter '.*' is not used in function signature",
      "confidence": "low",
      "reliability": "low",
      "severity": "low",
      "suggestion": "Phantom types are valid but ensure the generic parameter serves a purpose",
      "root_cause": "swift_generic_phantom",
      "tags": [
        "swift",
        "generics",
        "phantom",
        "unused"
      ],
      "description": "Swift Generic Phantom Type"
    },
    {
      "id": "swift_generic_higher_kinded_limitation",
      "category": "generics",
      "type": "higher_kinded",
      "pattern": "Cannot express higher-kinded type|Generic parameter cannot take generic parameters",
      "confidence": "medium",
      "reliability": "medium",
      "severity": "medium",
      "suggestion": "Swift doesn't support higher-kinded types. Use protocols with associated types as workaround",
      "root_cause": "swift_generic_higher_kinded",
      "tags": [
        "swift",
        "generics",
        "higher_kinded",
        "limitation"
      ],
      "description": "Swift Generic Higher Kinded Limitation"
    }
  ]
}